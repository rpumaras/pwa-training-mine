(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copy from https://github.com/brix/crypto-js/blob/master/sha1.js

// This file is modified so that we only keep the method definitions
// that we need for a full coverage test

// # License

// [The MIT License (MIT)](http://opensource.org/licenses/MIT)

// Copyright (c) 2009-2013 Jeff Mott  
// Copyright (c) 2013-2016 Evan Vosberg

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(CryptoJS) {

    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Reusable object
    var W = [];

    /**
     * SHA-1 hash algorithm.
     */
    /* eslint no-use-before-define: 0 */
    var SHA1 = C_algo.SHA1 = Hasher.extend({
        _doReset: function() {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476,
                0xc3d2e1f0
            ]);
        },

        _doProcessBlock: function(M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];

            // Computation
            for (var i = 0; i < 80; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = (n << 1) | (n >>> 31);
                }

                var t = ((a << 5) | (a >>> 27)) + e + W[i];
                if (i < 20) {
                    t += ((b & c) | (~b & d)) + 0x5a827999;
                } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                } else if (i < 60) {
                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                } else /* if (i < 80) */ {
                    t += (b ^ c ^ d) - 0x359d3e2a;
                }

                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
        },

        _doFinalize: function() {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA1('message');
     *     var hash = CryptoJS.SHA1(wordArray);
     */
    C.SHA1 = Hasher._createHelper(SHA1);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA1(message, key);
     */
    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
    /* eslint no-use-before-define: 2 */

    return CryptoJS.SHA1;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Relays sandy analytics js calls to the backend by use of a tracking pixel
 */

(function(root, factory) {
    if (true) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(__webpack_require__(0));
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['./lib/sha1/sha1'], factory);
    } else {
        root.Sandy = factory(root.CryptoJS.SHA1);
    }
})(this,
/*eslint max-statements: [2, 100] */
function(sha1) {
    var Sandy = {};
    Sandy._global = this;

    Sandy.version = '0.1.24';

    /**
     * Extract query parameter 'http://example.com?mobify_id=amp-aBcD1234'
     *
     * See http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
     */
    var extractIdFromUrl = function(name) {
        name = name || 'mobify_id';
        var regex = new RegExp('[?&]' + name + '=([\\w\\-]+)(&|#|$)');

        var url = Sandy._global.location && Sandy._global.location.href;
        if (url) {
            var result = regex.exec(url);
            if (result && result[1] && window.decodeURIComponent) {
                if (/^[a-fA-F0-9]{16}$/.test(result[1])) {
                    return result[1];
                } else {
                    var sha1MobifyId = sha1(result[1]).toString().substring(0, 16);
                    return window.decodeURIComponent(sha1MobifyId);
                }
            }
        }
        return null;
    };

    var Tracker = function(options) {
        options = options || {};

        this.dimensions = {};

        // get the slug form the options
        this.slug = options['slug'] || 'no-slug';

        // assign a unique id to this tracker
        this.dimensions['tracker_id'] = Sandy.Utils.generateRandomID();

        if (!Sandy.Utils.runningInServiceWorker()
            && 'cookie' in Sandy._global.document) {
            // get the shared pageview ID
            this.dimensions['pageview_id'] = Sandy._pageViewID;

            // get the potentially cookied session identifier
            this.dimensions['session_id'] = Sandy.getSessionID();

            // get the potentially cookied client identifier
            this.dimensions['client_id'] = Sandy.getClientID();

            // Cookie Domain
            if (options.cookieDomain === 'auto') {
                this.cookieDomain = Sandy._global.location.hostname;
            } else {
                this.cookieDomain = options['cookieDomain'] || Sandy._global.location.hostname;
            }

            /**
             * The following check if we need to send an associate event.
             *
             * An associate event is sent when:
             * 1. If we see the parameter `mobify_id` getting passed
             * 2. We see `client-id` cookie already that is different
             *
             * In this case we send an associate event to allow mapping the id between
             * the `mobify_id` query parameter and `client-id` cookies
             */
            var urlExtractedId = extractIdFromUrl();
            if (urlExtractedId && urlExtractedId !== this.dimensions['client_id']) {
                this.sendEvent({
                    dimensions : {
                        'associate_id': urlExtractedId
                    },
                    data : {
                        action: 'associate',
                        category: 'timing'
                    }
                });
            }
        }
    };

    /**
     * Sends an event, which is an object with keys `data`, and optionally,
     * `dimensions`. The value of the data key should be an object of the form
     * {
     *     "action": "DOMContentLoaded",
     *     "category": "timing",
     *     "value": 7
     * }
     * and `dimensions` can be any arbitrary object whose values are all of a
     * primitive type (boolean, number, string).
     *
     * The 'channel' property may set on the event - if it's missing (or falsy)
     * then 'web' is used.
     *
     * Optionally takes a node-style completion callback as a last parameter.
     */
    Tracker.prototype.sendEvent = function(event, callback) {
        event = Sandy.Utils.extend({},
            {
                'timestamp_local': event['timestamp_local'] || +new Date(),
                'channel': event.channel || 'web',
                'slug': this.slug,
                'dimensions': this.getDimensions(event.dimensions),
                'data': event.data
            }
        );
        Sandy._track(Sandy.endpoint, event, callback);
        return event;
    };

    /**
     * Takes a 'hitType' as its first argument, and then delegates to the
     * pageview(), event() or timing() methods based on that, passing the rest
     * of its arguments. Optionally takes a node-style completion callback as a
     * last parameter
     */
    Tracker.prototype.send = function(hitType) {
        var eventArgs = Array.prototype.slice.call(arguments, 1);
        if (Sandy.Utils.includes(['pageview', 'event', 'timing'], hitType)) {
            return this[hitType].apply(this, eventArgs);
        }
        Sandy.Utils.logError(new Error('Unrecognized hitType: ' + hitType));
    };

    Tracker.prototype.pageview = function(page) {
        var pageviewDimensions = {};
        var callback = Sandy.Utils.getCallback(arguments);

        try {
            if (typeof page === 'object') {
                pageviewDimensions = {
                    'page': page['page'] || Sandy._global.location.pathname,
                    'title': page['title'] || Sandy._global.document.title,
                    'location': page['location'] || Sandy._global.location.href
                };
            } else if (typeof page === 'string' || page instanceof String) {
                pageviewDimensions = {'page': page};
            } else {
                pageviewDimensions = {'page': Sandy._global.location.pathname};
            }

            pageviewDimensions['referrer'] = Sandy._global.document.referrer;

            this.set(pageviewDimensions);
            this.sendEvent({
                'data': {
                    'action': 'pageview'
                }
            }, callback);
        } catch (err) {
            Sandy.Utils.logError(err);
        }
    };

    var EVENT_KEYS = Sandy.EVENT_KEYS = {
        CHANNEL: 'eventChannel',
        CATEGORY: 'eventCategory',
        ACTION: 'eventAction',
        LABEL: 'eventLabel',
        VALUE: 'eventValue'
    };

    /**
     * Sends an arbitrary event, either with a explicit arguments of category,
     * action, label, value and dimensions, or reads them from an object with
     * keys 'eventCategory', 'eventAction', 'eventLabel', 'eventValue' with all
     * other key/values treated as dimensions. Optionally takes a node-style
     * completion callback as a last parameter
     */
    Tracker.prototype.event = function(category, action, label, value, dimensions) {
        var callback = Sandy.Utils.getCallback(arguments);
        var channel = null;

        if (typeof category === 'object') {
            action = category[EVENT_KEYS.ACTION];
            label = category[EVENT_KEYS.LABEL];
            value = category[EVENT_KEYS.VALUE];
            channel = category[EVENT_KEYS.CHANNEL];
            dimensions = Sandy.Utils.omit(category,
                [EVENT_KEYS.CATEGORY, EVENT_KEYS.ACTION, EVENT_KEYS.LABEL,
                EVENT_KEYS.VALUE]);
            // Category needs to be evaluated last so the rest of the variable
            // overwrites occur first
            category = category[EVENT_KEYS.CATEGORY];
        }
        this.sendEvent({
            'channel': channel,
            'data': {
                'category': category,
                'action': action,
                'label': label,
                'value': value
            },
            'dimensions': dimensions || {}
        }, callback);
    };

    var TIMING_KEYS = Sandy.TIMING_KEYS = {
        CATEGORY: 'timingCategory',
        ACTION: 'timingVar',
        LABEL: 'timingLabel',
        VALUE: 'timingValue'
    };


    /**
     * Sends a timing event, either with a explicit arguments of category,
     * action, label, value and dimensions, or reads them from an object with
     * keys 'timingCategory', 'timingVar', 'timingLabel', 'timingValue' with all
     * other key/values treated as dimensions. Optionally takes a node-style
     * completion callback as a last parameter
     */
    Tracker.prototype.timing = function(category, action, label, value, dimensions) {
        var callback = Sandy.Utils.getCallback(arguments);

        if (typeof category === 'object') {
            action = category[TIMING_KEYS.ACTION];
            label = category[TIMING_KEYS.LABEL];
            value = category[TIMING_KEYS.VALUE];
            dimensions = Sandy.Utils.omit(category,
                [TIMING_KEYS.CATEGORY, TIMING_KEYS.ACTION, TIMING_KEYS.LABEL,
                TIMING_KEYS.VALUE]);
            // Category needs to be evaluated last so the rest of the variable
            // overwrites occur first
            category = category[TIMING_KEYS.CATEGORY];
        }
        this.sendEvent({
            'data': {
                'category': category,
                'action': action,
                'label': label,
                'value': value
            },
            'dimensions': dimensions || {}
        }, callback);
    };

    /**
     * Takes a name/value pair, or a flat dictonary of keys and values and adds
     * them to this tracker's dimensions map.
     */
    Tracker.prototype.set = function(name, value) {
        if (typeof name === 'object' && value === undefined) {
            // we were passed an object, iterate over the keys
            for (var key in name) {
                if (name.hasOwnProperty(key)) {
                    this.set(key, name[key]);
                }
            }
            return;
        }
        this.dimensions[name] = value;
    };

    Tracker.prototype.get = function(name) {
        return this.dimensions[name];
    };

    /**
     * Returns a combination of tracker dimensions, default dimensions for the
     * page and any additional dimensions passed to it.
     */
    Tracker.prototype.getDimensions = function(additional) {
        if (additional !== undefined) {
            return Sandy.Utils.extend({}, Sandy._gatherDefaultDimensions(),
                                      this.dimensions,
                                      additional);
        }
        return Sandy.Utils.extend({}, Sandy._gatherDefaultDimensions(),
            this.dimensions);
    };

    Sandy.Tracker = Tracker;

    /**
     * Returns default dimension values that we expect to collect on any page.
     */
    Sandy._gatherDefaultDimensions = function() {
        if (Sandy.Utils.runningInServiceWorker()) {
            return {
                version: Sandy.version
            };
        }

        return {
            location: Sandy._global.location.href,
            page: Sandy._global.location.pathname,
            title: Sandy._global.document.title,
            version: Sandy.version
        };
    };

    /* Sandy.Utils namespace */
    Sandy.Utils = {};

    /**
     * Sandy.Utils.logError() takes an exception and logs it to console.error if
     * available.
     */
    Sandy.Utils.logError = function(error) {
        if (window.console && window.console.error) {
            console.error(error);
        }
    };

    /*
     * Sandy.Utils.getCallback checks the last argument of a function's
     * parameters for a callback. Returns the callback if true.
    */
    Sandy.Utils.getCallback = function(args) {
        var lastArgument = args[args.length - 1];
        if (typeof lastArgument === 'function') {
            return lastArgument;
        }
    };

    /**
     * Sandy.Utils.encodeQueryString encodes the data in a suitable format
     * for a URL.
     *
     * Top level primatives are encoded directly, objects are encoded
     * as JSON and stringified.
     *
     * Data returned from `_encodeQueryString` will be safely embeddedable
     * in a URL. It is not necessary to escape it.
     */
    Sandy.Utils.encodeQueryString = function(data) {
        var components = [];

        for (var key in data) {
            if (data.hasOwnProperty(key)) {
                var value = data[key];

                if (typeof value === 'string' || value instanceof String) {
                    components.push(key + '=' + encodeURIComponent(value.toString()));
                } else if (typeof value === 'number') {
                    components.push(key + '=' + value.toString());
                } else if (typeof value === 'boolean') {
                    components.push(key + '=' + (value ? 'true' : 'false'));
                } else if (typeof value === 'object' && value) {
                    components.push(key + '=' + encodeURIComponent(JSON.stringify(value)));
                }
            }
        }
        return '?' + components.join('&');
    };

    /**
     * Generates a unique ID as a 16-character string.
     */
    Sandy.Utils.generateRandomID = function() {
        var characters = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        var id = [];

        for (var i = 0; i < 16; i++) {
            var charIndex = Math.floor(Math.random() * 16);
            id.push(characters[charIndex]);
        }

        return id.join('');
    };

    /**
     * Reads a cookie with the given name.
     *
     * Note: the name is prefixed with "sandy-" before lookup.
     */
    Sandy.Utils.getCookie = function(name) {
        var cookieRe = new RegExp('sandy-' + name + '=([^;]+)');
        var match = cookieRe.exec(Sandy._global.document.cookie);

        return match ? match[1] : '';
    };

    /**
     * Sets a cookie with the given name and value.
     * If a lifetime value is given, the expiry will be set to lifetime
     * seconds in the future. Otherwise, the expiry is 30 days.
     *
     * If domain is given, the cookie is set with that domain.
     *
     * Note: the name is prefixed with "sandy-" before lookup.
     */
    Sandy.Utils.setCookie = function(name, value, domain, lifetime) {
        var expires = new Date();
        var now = +expires; //type coerce to timestamp

        if (lifetime > 0) {
            // Lifetime (seconds) in to the future
            expires.setTime(now + lifetime * 1000);
        } else {
            // 30 Days in to the future
            expires.setTime(now + 30 * 24 * 3600 * 1000);
        }
        Sandy._global.document.cookie = 'sandy-' + name + '=' + value + '; expires=' +
            expires.toGMTString() + '; path=/; ' + (domain && domain !== 'localhost' ? 'domain=' + domain : '');
    };

    /**
     * Takes an object `target`, and one or more other objects. key/value pairs
     * from the object are copied into target, with keys from objects later in
     * the argument list taking precedence.
     */
    Sandy.Utils.extend = function(target) {
        var obj;
        for (var i = 0, len = arguments.length; i < len; i++) {
            obj = arguments[i];
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    target[key] = obj[key];
                }
            }
        }
        return target;
    };

    /**
     * Returns true if `array` has an element `item`, false
     * otherwise.
     */
    Sandy.Utils.includes = function(array, item) {
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === item) {
                return true;
            }
        }
        return false;
    };

    /**
     * Returns true if client is running in a service worker
     */
    Sandy.Utils.runningInServiceWorker = function() {
        return typeof Sandy._global.document === 'undefined';
    };


    /**
     * Takes an object, `object` and array of key names, `keys`. Returns a copy
     * of the object, but without the keys (and values of those keys) named in
     * `keys`.
     */
    Sandy.Utils.omit = function(object, keys) {
        var target = {};
        for (var key in object) {
            if (object.hasOwnProperty(key) &&
                    !Sandy.Utils.includes(keys, key)) {
                target[key] = object[key];
            }
        }
        return target;
    };

    /**
     * Sandy.getSesssionID returns an ID tied to a user's session. A session
     * expires after 30 minutes of inactivity.
     */
    Sandy.getSessionID = function(domain) {
        var id = Sandy.Utils.getCookie('session-id');
        id = id || Sandy.Utils.generateRandomID();

        // Push the session expiry 30 minutes in to the future
        Sandy.Utils.setCookie('session-id', id, domain, 1800);

        return id;
    };

    // 2 years, expressed in seconds. This value is intentionally exposed
    // to developers.
    Sandy.CLIENT_COOKIE_LIFETIME_SECONDS = 2 * 52 * 7 * 24 * 3600;

    /**
     * Sandy.getClientID returns an ID tied to a user's client/browser.
     * As of MTT-460, this expires 2 years after last use. Each use
     * extends the lifetime.
     */
    Sandy.getClientID = function(domain) {
        var id = Sandy.Utils.getCookie('client-id') ||
                extractIdFromUrl() ||
                Sandy.Utils.generateRandomID();
        Sandy.setClientID(id, domain);
        return id;
    };

    /**
     * Set the cookie, with a long expiration. This will also
     * extend the lifetime of the cookie on every call.
     *
     * Note:
     * 1. This changes the ID on all sandy trackers
     * 2. This will not send an associate event
     *
     * @param {string} id ID to set the clientID to.
     * @param {string} [domain] Optional domain to passed to setCookie
     */
    Sandy.setClientID = function(id, domain) {
        Sandy.Utils.setCookie(
            'client-id',
            id,
            domain,
            Sandy.CLIENT_COOKIE_LIFETIME_SECONDS
        );
    };

    /**
     * Dispatch commands passed to the `sandy()` function:
     *     - call callbacks
     *     - create trackers
     *     - dispatch send/set comamnds on default tracker
     *     - fail noisily
     */
    Sandy.dispatchCommand = function() {
        var command = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);

        Sandy.trackers = Sandy.trackers || {};
        var defaultTracker = Sandy.trackers[Sandy.DEFAULT_TRACKER_NAME];

        if (typeof command === 'function') {
            try {
                return command(defaultTracker);
            } catch (e) {
                Sandy.Utils.logError(e);
                return;
            }
        }

        if (typeof command === 'string' || command instanceof String) {
            if (command === 'create') {
                return Sandy.create.apply(this, args);
            }
            if (Sandy.Utils.includes(['send', 'set'], command)) {
                return defaultTracker[command].apply(defaultTracker, args);
            }
            if (typeof args[0] === 'object') {
                return defaultTracker['send'].apply(defaultTracker, args);
            }
        }
        Sandy.Utils.logError(new Error('Unable to dispatch command: ' +
                                       command));
    };

    /**
     * Creates or mutates the tracker `name` to have the slug `slug` and cookie
     * domain `cookieDomain`. If `name` is not specified, the default tracker is
     * created or mutated.
     */
    Sandy.create = function(slug, cookieDomain, name) {
        if (typeof slug === 'object') {
            cookieDomain = slug['cookieDomain'] || 'auto';
            name = slug['name'];
            slug = slug['trackingId'];
        }
        if (!(typeof slug === 'string'  || slug instanceof String)) {
            Sandy.Utils.logError(new Error('slug was not a string'));
            return;
        }
        name = name || Sandy.DEFAULT_TRACKER_NAME;
        Sandy.trackers = Sandy.trackers || {};

        var tracker = Sandy.trackers[name];

        // MTT-463 - if there is an existing tracker, then we don't
        // modify it. The parameters from the first 'create' remain.
        // Thus we only setup a new tracker if there is no existing tracker.
        if (!tracker) {
            Sandy.trackers[name] = tracker = new Tracker({
                slug: slug,
                cookieDomain: cookieDomain
            });
        }

        return tracker;
    };

    /**
     * Takes an array of sandy commands, `queue`, and calls
     * Sandy.dispatchCommand() on each of them.
     */
    Sandy.drainQueue = function(queue) {
        var command;
        while (command = queue.shift()) {
            Sandy.dispatchCommand.apply(undefined, command);
        }
    };

    Sandy.isInitialised = function(window) {
        return window['SandyAnalyticsObject']
                && window[window['SandyAnalyticsObject']]
                && window[window['SandyAnalyticsObject']].initialised;
    };

    /** side-effecty imperative bit, also a reimplimentation of the snippet **/
    Sandy.init = function(window, options) {
        var sandyName = 'sandy';
        if (options && options.name) {
            sandyName = options.name;
        }
        // if init has already run by another tracker, bail
        if (window['SandyAnalyticsObject'] === sandyName && Sandy.isInitialised(window)) {
            return;
        }
        window['SandyAnalyticsObject'] = window['SandyAnalyticsObject'] || sandyName;
        window[sandyName] = window[sandyName] || function() {
            return window[sandyName].q.push(arguments);
        };
        var queue = window[sandyName].q = window[sandyName].q || [];
        window[sandyName].initialised = true;

        Sandy.drainQueue(queue);

        // substitute implementation of push
        window[sandyName].q.push = function() {
            // expand arguments out and send them to dispatchCommand
            Sandy.dispatchCommand.apply(undefined, arguments[0]);
        };
    };

    // Assign a unique pageview ID every time the script is loaded
    Sandy._pageViewID = Sandy.Utils.generateRandomID();

    // tracking pixel url
    Sandy.endpoint = 'https://engagement-collector.mobify.net/s.gif';

    // Name of the default tracker
    Sandy.DEFAULT_TRACKER_NAME = 't0';

    // Default iframe to be used
    Sandy.iframe = null;

    /*
     * Uses the service workers fetch api to fire the tracking pixel.
     */
    Sandy._trackFetch = function(src, callback) {
        self.fetch(src, {mode: 'no-cors'}).then(function(value) {
            if (typeof callback === 'function') {
                callback(null);
            }
        })['catch'](function() {
            if (typeof callback === 'function') {
                callback(new Error('Error loading ' + src));
            }
        });
    };

    /*
     * Uses an Image object to fire the tracking pixel.
     */
    Sandy._trackImage = function(src, callback) {
        var image = new Image();
        image.src = src;

        if (typeof callback === 'function') {
            image.onload = function() {
                callback(null);
            };
            image.onerror = function() {
                callback(new Error('Error loading ' + image.src));
            };
        }
        return image;
    };

    Sandy._sendAjax = function(src, callback) {
        if (!Sandy.iframe) {
            callback(new Error('No iframe provided - cannot send'));
            return;
        }

        if (!Sandy.iframe.contentWindow) {
            // iframe is not ready - start queueing events
            Sandy.iframeQueue.push(src);
            return;
        }

        // Create XHR and send the request.
        var xhr = new Sandy.iframe.contentWindow.XMLHttpRequest();
        xhr.open('GET', src);
        xhr.send(null);
    };

    Sandy._iframeDrainQueue = function() {
        // Flush iframe queue
        var xhr = new Sandy.iframe.contentWindow.XMLHttpRequest();
        while (Sandy.iframeQueue.length) {
            xhr.open('GET', Sandy.iframeQueue.shift());
            xhr.send(null);
        }

        Sandy.iframeQueue.push = function(src) {
            xhr.open('GET', src);
            xhr.send(null);
        };
    };

    /*
     * Uses an iframe XHR object to fire the tracking pixel.
     */
    Sandy._trackAjax = function(src, callback) {
        // Due to an issue with Hijax, we create an iframe to have a clean
        // window object and unpatched XHR object to send the tracking pixel
        // request.
        if (Sandy.iframe === null) {
            // from http://www.paulirish.com/2011/surefire-dom-element-insertion/
            var ref = document.getElementsByTagName('script')[0];
            if (!ref) {
                // let's be defensive and just skip the send
                callback(new Error('Error creating iframe ajax call'));
                Sandy.iframe = undefined;
                return;
            }
            Sandy.iframe = document.createElement('iframe');
            Sandy.iframe.style.display = 'none';
            // Add an attribute to meet WCAG accessibility guideline
            Sandy.iframe.setAttribute('title', 'Analytics');

            // https://stackoverflow.com/questions/10781880/dynamically-created-iframe-triggers-onload-event-twice
            ref.parentNode.insertBefore(Sandy.iframe, ref);

            Sandy.iframeQueue = [src];
            Sandy.iframe.onload = Sandy._iframeDrainQueue;
        } else {
            Sandy._sendAjax(src, callback);
        }
    };

    /*
     * Fires a tracking pixel with event data set on the querystring to the
     * passed endpoint.
     */
    Sandy._track = function(endpoint, data, callback) {
        var qs = Sandy.Utils.encodeQueryString(data);
        var src = endpoint + qs;

        if (Sandy.Utils.runningInServiceWorker()) {
            // Fetch api case.
            Sandy._trackFetch(src, callback);
        } else if (
            Sandy._global.XMLHttpRequest
            && 'withCredentials' in new Sandy._global.XMLHttpRequest
        ) {
            // XHR with CORs
            Sandy._trackAjax(src, callback);
        } else {
            Sandy._trackImage(src, callback);
        }
    };

    if (window && window.sandy) {
        window.sandy.instance = Sandy;
    }

    return Sandy;
});


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// https://github.com/brix/crypto-js/blob/master/core.js

// This file is modified so that we only keep the method definitions
// that we need for a full coverage test

// # License

// [The MIT License (MIT)](http://opensource.org/licenses/MIT)

// Copyright (c) 2009-2013 Jeff Mott  
// Copyright (c) 2013-2016 Evan Vosberg

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {

    /**
     * CryptoJS core components.
     */
    /* eslint no-use-before-define: 0 */
    var CryptoJS = CryptoJS || (function(Math, undefined) {
        /*
         * Local polyfil of Object.create
         */
        var create = Object.create || (function() {
            function F() {}

            return function(obj) {
                var subtype;

                F.prototype = obj;

                subtype = new F();

                F.prototype = null;

                return subtype;
            };
        }());

        /**
         * CryptoJS namespace.
         */
        var C = {};

        /**
         * Library namespace.
         */
        var C_lib = C.lib = {};

        /**
         * Base object for prototypal inheritance.
         */
        var Base = C_lib.Base = (function() {


            return {
                /**
                 * Creates a new object that inherits from this object.
                 *
                 * @param {Object} overrides Properties to copy into the new object.
                 *
                 * @return {Object} The new object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var MyType = CryptoJS.lib.Base.extend({
                 *         field: 'value',
                 *
                 *         method: function() {
                 *         }
                 *     });
                 */
                extend: function(overrides) {
                    // Spawn
                    var subtype = create(this);

                    // Augment
                    if (overrides) {
                        subtype.mixIn(overrides);
                    }

                    // Create default initializer
                    if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                        subtype.init = function() {
                            subtype.$super.init.apply(this, arguments);
                        };
                    }

                    // Initializer's prototype is the subtype object
                    subtype.init.prototype = subtype;

                    // Reference supertype
                    subtype.$super = this;

                    return subtype;
                },

                /**
                 * Initializes a newly created object.
                 * Override this method to add some logic when your objects are created.
                 *
                 * @example
                 *
                 *     var MyType = CryptoJS.lib.Base.extend({
                 *         init: function() {
                 *             // ...
                 *         }
                 *     });
                 */
                init: function() {
                },

                /**
                 * Copies properties into this object.
                 *
                 * @param {Object} properties The properties to mix in.
                 *
                 * @example
                 *
                 *     MyType.mixIn({
                 *         field: 'value'
                 *     });
                 */
                mixIn: function(properties) {
                    for (var propertyName in properties) {
                        if (properties.hasOwnProperty(propertyName)) {
                            this[propertyName] = properties[propertyName];
                        }
                    }

                    // IE won't copy toString using the loop above
                    if (properties.hasOwnProperty('toString')) {
                        this.toString = properties.toString;
                    }
                }
            };
        }());

        /**
         * An array of 32-bit words.
         *
         * @property {Array} words The array of 32-bit words.
         * @property {number} sigBytes The number of significant bytes in this word array.
         */
        var WordArray = C_lib.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of 32-bit words.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.create();
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
             */
            init: function(words, sigBytes) {
                words = this.words = words || [];

                if (sigBytes != undefined) {
                    this.sigBytes = sigBytes;
                } else {
                    this.sigBytes = words.length * 4;
                }
            },

            /**
             * Converts this word array to a string.
             *
             * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
             *
             * @return {string} The stringified word array.
             *
             * @example
             *
             *     var string = wordArray + '';
             *     var string = wordArray.toString();
             *     var string = wordArray.toString(CryptoJS.enc.Utf8);
             */
            toString: function(encoder) {
                return (encoder || Hex).stringify(this);
            },

            /**
             * Concatenates a word array to this word array.
             *
             * @param {WordArray} wordArray The word array to append.
             *
             * @return {WordArray} This word array.
             *
             * @example
             *
             *     wordArray1.concat(wordArray2);
             */
            concat: function(wordArray) {
                // Shortcuts
                var thisWords = this.words;
                var thatWords = wordArray.words;
                var thisSigBytes = this.sigBytes;
                var thatSigBytes = wordArray.sigBytes;

                // Clamp excess bits
                this.clamp();

                // Concat
                if (thisSigBytes % 4) {
                    // Copy one byte at a time
                    for (var i = 0; i < thatSigBytes; i++) {
                        var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                    }
                } else {
                    // Copy one word at a time
                    for (var i = 0; i < thatSigBytes; i += 4) {
                        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                    }
                }
                this.sigBytes += thatSigBytes;

                // Chainable
                return this;
            },

            /**
             * Removes insignificant bits.
             *
             * @example
             *
             *     wordArray.clamp();
             */
            clamp: function() {
                // Shortcuts
                var words = this.words;
                var sigBytes = this.sigBytes;

                // Clamp
                words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                words.length = Math.ceil(sigBytes / 4);
            }
        });

        /**
         * Encoder namespace.
         */
        var C_enc = C.enc = {};

        /**
         * Hex encoding strategy.
         */
        var Hex = C_enc.Hex = {
            /**
             * Converts a word array to a hex string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The hex string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
             */
            stringify: function(wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;

                // Convert
                var hexChars = [];
                for (var i = 0; i < sigBytes; i++) {
                    var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    hexChars.push((bite >>> 4).toString(16));
                    hexChars.push((bite & 0x0f).toString(16));
                }

                return hexChars.join('');
            }
        };

        /**
         * Latin1 encoding strategy.
         */
        var Latin1 = C_enc.Latin1 = {
            /**
             * Converts a Latin1 string to a word array.
             *
             * @param {string} latin1Str The Latin1 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
             */
            parse: function(latin1Str) {
                // Shortcut
                var latin1StrLength = latin1Str.length;

                // Convert
                var words = [];
                for (var i = 0; i < latin1StrLength; i++) {
                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                }

                return new WordArray.init(words, latin1StrLength);
            }
        };

        /**
         * UTF-8 encoding strategy.
         */
        var Utf8 = C_enc.Utf8 = {
            /**
             * Converts a UTF-8 string to a word array.
             *
             * @param {string} utf8Str The UTF-8 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
             */
            parse: function(utf8Str) {
                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
            }
        };

        /**
         * Abstract buffered block algorithm template.
         *
         * The property blockSize must be implemented in a concrete subtype.
         *
         * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
         */
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
            /**
             * Resets this block algorithm's data buffer to its initial state.
             *
             * @example
             *
             *     bufferedBlockAlgorithm.reset();
             */
            reset: function() {
                // Initial values
                this._data = new WordArray.init();
                this._nDataBytes = 0;
            },

            /**
             * Adds new data to this block algorithm's buffer.
             *
             * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
             *
             * @example
             *
             *     bufferedBlockAlgorithm._append('data');
             *     bufferedBlockAlgorithm._append(wordArray);
             */
            _append: function(data) {
                // Convert string to WordArray, else assume WordArray already
                if (typeof data == 'string') {
                    data = Utf8.parse(data);
                }

                // Append
                this._data.concat(data);
                this._nDataBytes += data.sigBytes;
            },

            /**
             * Processes available data blocks.
             *
             * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
             *
             * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
             *
             * @return {WordArray} The processed data.
             *
             * @example
             *
             *     var processedData = bufferedBlockAlgorithm._process();
             *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
             */
            _process: function(doFlush) {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var dataSigBytes = data.sigBytes;
                var blockSize = this.blockSize;
                var blockSizeBytes = blockSize * 4;

                // Count blocks ready
                var nBlocksReady = dataSigBytes / blockSizeBytes;
                if (doFlush) {
                    // Round up to include partial blocks
                    nBlocksReady = Math.ceil(nBlocksReady);
                } else {
                    // Round down to include only full blocks,
                    // less the number of blocks that must remain in the buffer
                    nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                }

                // Count words ready
                var nWordsReady = nBlocksReady * blockSize;

                // Count bytes ready
                var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

                // Process blocks
                if (nWordsReady) {
                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                        // Perform concrete-algorithm logic
                        this._doProcessBlock(dataWords, offset);
                    }

                    // Remove processed words
                    var processedWords = dataWords.splice(0, nWordsReady);
                    data.sigBytes -= nBytesReady;
                }

                // Return processed words
                return new WordArray.init(processedWords, nBytesReady);
            },

            _minBufferSize: 0
        });

        /**
         * Abstract hasher template.
         *
         * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
         */
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             */
            cfg: Base.extend(),

            /**
             * Initializes a newly created hasher.
             *
             * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
             *
             * @example
             *
             *     var hasher = CryptoJS.algo.SHA256.create();
             */
            init: function(cfg) {
                // Apply config defaults
                this.cfg = this.cfg.extend(cfg);

                // Set initial values
                this.reset();
            },

            /**
             * Resets this hasher to its initial state.
             *
             * @example
             *
             *     hasher.reset();
             */
            reset: function() {
                // Reset data buffer
                BufferedBlockAlgorithm.reset.call(this);

                // Perform concrete-hasher logic
                this._doReset();
            },

            /**
             * Finalizes the hash computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The hash.
             *
             * @example
             *
             *     var hash = hasher.finalize();
             *     var hash = hasher.finalize('message');
             *     var hash = hasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
                // Final message update
                if (messageUpdate) {
                    this._append(messageUpdate);
                }

                // Perform concrete-hasher logic
                var hash = this._doFinalize();

                return hash;
            },

            blockSize: 512/32,

            /**
             * Creates a shortcut function to a hasher's object interface.
             *
             * @param {Hasher} hasher The hasher to create a helper for.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
             */
            _createHelper: function(hasher) {
                return function(message, cfg) {
                    return new hasher.init(cfg).finalize(message);
                };
            },

            /**
             * Creates a shortcut function to the HMAC's object interface.
             *
             * @param {Hasher} hasher The hasher to use in this HMAC helper.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
             */
            _createHmacHelper: function(hasher) {
                return function(message, key) {
                    return new C_algo.HMAC.init(hasher, key).finalize(message);
                };
            }
        });

        /**
         * Algorithm namespace.
         */
        var C_algo = C.algo = {};

        return C;
    }(Math));
    /* eslint no-use-before-define: 2 */

    return CryptoJS;

}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ })
/******/ ]);
});