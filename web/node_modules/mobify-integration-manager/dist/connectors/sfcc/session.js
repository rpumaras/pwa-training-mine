'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.initSfccAuthAndSession = exports.requestGuestAuthorizationToken = exports.bridgeOcapiToDesktopSession = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _fetchUtils = require('progressive-web-sdk/dist/utils/fetch-utils');

var _config = require('./config');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FIVE_MIN_IN_SECONDS = 5 * 60; // seconds

/**
 * Bridges an OCAPI (JWT token) session to desktop session.
 * @warn  This is almost certainly not the function you want.
 * @param {string} authorization The JWT token (in the same form it's returned
 *                               to by `POST /customers/auth`. ie. 'Bearer aec9293229...'
 *
 * {@link https://documentation.demandware.com/DOC1/topic/com.demandware.dochelp/OCAPI/17.7/shop/Resources/Sessions.html#id-2104283703__id-514053870|Sessions}
 */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2017 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

var bridgeOcapiToDesktopSession = exports.bridgeOcapiToDesktopSession = function bridgeOcapiToDesktopSession(authorization) {
    var options = {
        method: 'POST',
        headers: (0, _extends3.default)({}, (0, _config.getRequestHeaders)(), {
            Authorization: authorization
        })

        // The sessions endpoint will set cookies if it succeeds.
        // If it fails, it returns JSON which contains a `fault` key
        // that describes the error.
    };return (0, _fetchUtils.makeRequest)((0, _config.getApiEndPoint)() + '/sessions', options).then(function (response) {
        if (!response.ok) {
            return response.json();
        }

        return _promise2.default.resolve({});
    }).then(function (_ref) {
        var fault = _ref.fault;

        if (fault) {
            throw new Error(fault.message);
        }
    });
};

var isNearingExpiry = function isNearingExpiry(authorizationToken) {
    var _getAuthTokenPayload = (0, _utils.getAuthTokenPayload)(authorizationToken),
        exp = _getAuthTokenPayload.exp;

    // Get current Unix time in seconds (not milliseconds)


    var currentTimeInMin = Math.floor(Date.now() / 1000);
    var minutesToExpiry = exp - currentTimeInMin;
    var isAboutToExpire = minutesToExpiry < FIVE_MIN_IN_SECONDS;

    if (isAboutToExpire) {
        console.info('Auth token expires in ' + minutesToExpiry + ' minute(s) at ' + new Date(exp * 1000) + '. Refreshing now!');
    }

    return isAboutToExpire;
};

var initDesktopSession = function initDesktopSession() {
    return (0, _fetchUtils.makeRequest)((0, _config.getHomeURL)());
};

var requestBridgedAuthorizationToken = function requestBridgedAuthorizationToken() {
    var options = {
        method: 'POST',
        body: (0, _stringify2.default)({ type: 'session' }), // 'session' means bridge
        headers: (0, _config.getRequestHeaders)()
    };

    return (0, _fetchUtils.makeRequest)((0, _config.getApiEndPoint)() + '/customers/auth', options);
};

var requestGuestAuthorizationToken = exports.requestGuestAuthorizationToken = function requestGuestAuthorizationToken() {
    var options = {
        method: 'POST',
        body: (0, _stringify2.default)({ type: 'guest' }),
        headers: (0, _config.getRequestHeaders)()
    };

    return (0, _fetchUtils.makeRequest)((0, _config.getApiEndPoint)() + '/customers/auth', options);
};

/**
 * Requests an authorization (JWT) token using the 'session' option to bridge
 * an existing desktop session (meaning that if the user was logged in on
 * desktop, they will be logged in for OCAPI calls).
 *
 * @returns {object} the set of headers needed to make authenticated OCAPI calls
 */
var requestAuthorizationToken = function requestAuthorizationToken() {
    var requestAuthToken = (0, _config.getShouldBridgeDesktopSession)() ? requestBridgedAuthorizationToken : requestGuestAuthorizationToken;

    return requestAuthToken().then(function (response) {
        if (response.status === 401) {
            return response.json().then(function (_ref2) {
                var fault = _ref2.fault;

                console.error('Server denied session initialization. Starting a new session.');
                console.error('  Details:', fault.message);

                (0, _utils.deleteBasketID)();
                (0, _utils.deleteAuthToken)();

                if ((0, _config.getShouldBridgeDesktopSession)()) {
                    return initDesktopSession().then(requestAuthorizationToken);
                } else {
                    return requestAuthorizationToken();
                }
            });
        }

        var authorizationToken = response.headers.get('Authorization');
        (0, _utils.storeAuthToken)(authorizationToken);

        return (0, _extends3.default)({}, (0, _config.getRequestHeaders)(), {
            Authorization: authorizationToken
        });
    });
};

/**
 * Refreshes the given authorization token
 * @param {string} authorizationToken The 'Bearer: ...' token provided by the SFCC server
 */
var refreshAuthorizationToken = function refreshAuthorizationToken(authorizationToken) {
    var requestOptions = {
        method: 'POST',
        body: (0, _stringify2.default)({ type: 'refresh' }),
        headers: (0, _extends3.default)({}, (0, _config.getRequestHeaders)(), {
            Authorization: authorizationToken
        })
    };

    return (0, _fetchUtils.makeRequest)((0, _config.getApiEndPoint)() + '/customers/auth', requestOptions).then(function (response) {
        if (response.status === 401) {
            console.log('Could not refresh auth token. Re-initializing session from scratch.');

            // The server did not accept the token, start from scratch
            (0, _utils.deleteAuthToken)();
            return requestAuthorizationToken();
        }

        var authorizationToken = response.headers.get('Authorization');
        (0, _utils.storeAuthToken)(authorizationToken);
        return (0, _extends3.default)({}, (0, _config.getRequestHeaders)(), {
            Authorization: authorizationToken
        });
    });
};

var initSfccAuthAndSession = exports.initSfccAuthAndSession = function initSfccAuthAndSession() {
    var authorizationToken = (0, _utils.getAuthToken)();
    if (authorizationToken) {
        if (isNearingExpiry(authorizationToken)) {
            return refreshAuthorizationToken(authorizationToken);
        }

        // The token is still valid and has time on it yet
        return _promise2.default.resolve((0, _extends3.default)({}, (0, _config.getRequestHeaders)(), {
            Authorization: authorizationToken
        }));
    }

    return requestAuthorizationToken();
};