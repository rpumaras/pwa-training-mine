#!/usr/bin/env node
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

'use strict'

const fs = require('fs')
const uploadBundle = require('../scripts/upload.js')
const Utils = require('../scripts/utils.js')

const POTENTIAL_OPTIONS = {
    buildDirectory: 'b',
    message: 'm',
    projectSlug: 's',
    target: 't'
}

const argv = require('yargs')
    .usage('Usage: $0 [options]')
    .option(POTENTIAL_OPTIONS.buildDirectory, {
        alias: 'buildDirectory',
        describe: 'a custom project directory where your build is located. default: "build/"'
    })
    .option(POTENTIAL_OPTIONS.message, {
        alias: 'message',
        describe: 'a message to include along with the uploaded bundle in Mobify Cloud. default: <git branch>: <git commit hash>',
        type: 'string'
    })
    .option(POTENTIAL_OPTIONS.projectSlug, {
        alias: 'projectSlug',
        describe: 'a project slug that differs from the name property in your project\'s package.json. default: the \'name\' key from the package.json', // eslint-disable-line max-len
        type: 'string'
    })
    .option(POTENTIAL_OPTIONS.target, {
        alias: 'target',
        describe: 'a custom target to upload a bundle to within Mobify Cloud',
        type: 'string'
    })
    .help('h')
    .alias('h', 'help')
    .strict()
    .argv

if (typeof argv.projectSlug === 'undefined') {
    try {
        // Assumption: this binary is invoked from the project root directory
        const packageJson = fs.readFileSync('package.json', {encoding: 'utf8'})
        argv.projectSlug = JSON.parse(packageJson).name
    } catch (e) {
        let message
        if (e.code === 'ENOENT' && e.path === 'package.json') {
            message = '[Error: package.json not found. Are you running this command in the project root directory?]' // eslint-disable-line max-len
        } else {
            message = e.message
        }

        Utils.fail(message)
    }
}

// Filter out undefined options
const options = {}
for (const opt in POTENTIAL_OPTIONS) {
    if (typeof argv[opt] !== 'undefined') {
        options[opt] = argv[opt]
    }
}

uploadBundle(options).catch((err) => {
    console.error(err.message || err)
})
