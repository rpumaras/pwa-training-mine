/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

const {propertyTypeInfo, typeToRecord} = require('./extract-records')
import _ from 'lodash'

jest.mock('./prepare-record')
const {storeAlias} = require('./prepare-record')

/* eslint-disable max-nested-callbacks */

const methodProxyObject = (obj) => _.mapValues(obj, (value) => () => value)

describe('propertyTypeInfo', () => {
    describe('value types', () => {
        test('returns the primitive names if passed an ordinary primitive', () => {
            [
                ['StringType', 'string'],
                ['NumberType', 'number'],
                ['BooleanType', 'boolean'],
                ['IntegerType', 'number']
            ].forEach(([nameId, type]) => {
                expect(propertyTypeInfo(methodProxyObject({
                    nameId,
                    isValueType: true
                }))).toEqual({type, custom: false})
            })
        })

        test('returns the name if not found in the standard primitives', () => {
            expect(propertyTypeInfo(methodProxyObject({
                nameId: 'Alias',
                isValueType: true
            }))).toEqual({type: 'Alias', custom: false})
        })

        test('returns the supertype info if the type is anonymous', () => {
            expect(propertyTypeInfo(methodProxyObject({
                isValueType: true,
                nameId: null,
                superTypes: [methodProxyObject({
                    isValueType: true,
                    nameId: 'IntegerType'
                })]
            }))).toEqual({type: 'number', custom: false})
        })
    })

    describe('union types', () => {
        test('returns the right type info if the left type is nil', () => {
            expect(propertyTypeInfo(methodProxyObject({
                isValueType: false,
                isUnion: true,
                leftType: methodProxyObject({nameId: 'nil'}),
                rightType: methodProxyObject({nameId: 'StringType', isValueType: true})
            }))).toEqual({
                nullable: true,
                type: 'string',
                custom: false
            })
        })


        test('returns the left type info if the right type is nil', () => {
            expect(propertyTypeInfo(methodProxyObject({
                isValueType: false,
                isUnion: true,
                leftType: methodProxyObject({nameId: 'StringType', isValueType: true}),
                rightType: methodProxyObject({nameId: 'nil'})
            }))).toEqual({
                nullable: true,
                type: 'string',
                custom: false
            })
        })

        test('prints an error if neither type is nil', () => {
            const _consoleError = console.error
            const errorMock = jest.fn()
            console.error = errorMock
            propertyTypeInfo(methodProxyObject({
                isValueType: false,
                isUnion: true,
                isArray: false,
                isObject: false,
                nameId: 'Union',
                leftType: methodProxyObject({nameId: 'StringType'}),
                rightType: methodProxyObject({nameId: 'StringType'})
            }))
            console.error = _consoleError

            expect(errorMock).toBeCalled()
        })
    })

    describe('array types', () => {
        test('returns an appropriate list type', () => {
            expect(propertyTypeInfo(methodProxyObject({
                isValueType: false,
                isUnion: false,
                isArray: true,
                componentType: methodProxyObject({nameId: 'Element'})
            }))).toEqual({
                defaultValue: 'Immutable.List()',
                propType: 'PropTypes.instanceOf(Immutable.List)',
                type: 'Element'
            })
        })
    })

    describe('object types', () => {
        test('treats a type with an id of object as an arbitrary primitive object', () => {
            expect(propertyTypeInfo(methodProxyObject({
                isValueType: false,
                isUnion: false,
                isArray: false,
                isObject: true,
                nameId: 'object'
            }))).toEqual({
                type: 'object',
                custom: false
            })
        })

        test('treats any other object type as a custom type', () => {
            expect(propertyTypeInfo(methodProxyObject({
                isValueType: false,
                isUnion: false,
                isArray: false,
                isObject: true,
                nameId: 'Item'
            }))).toEqual({
                type: 'Item',
                custom: true
            })

        })
    })
})

describe('typeToRecord', () => {
    test('stores an alias if the root type is a value type', () => {
        storeAlias.mockClear()

        const type = methodProxyObject({
            name: 'Alias',
            runtimeDefinition: methodProxyObject({
                isValueType: true,
                superTypes: [methodProxyObject({nameId: 'StringType'})]
            })
        })

        expect(typeToRecord(type)).toBeNull()

        expect(storeAlias).toBeCalledWith('Alias', 'string')
    })

    test('generates contents from the properties of a root object type', () => {
        expect(typeToRecord(methodProxyObject({
            name: 'ObjectRecord',
            runtimeDefinition: methodProxyObject({
                isValueType: false,
                allProperties: [
                    {
                        nameId: 'value',
                        range: methodProxyObject({isValueType: true, nameId: 'BooleanType'})
                    },
                    {
                        nameId: 'item',
                        range: methodProxyObject({isValueType: true, nameId: 'StringType'})
                    }
                ].map(methodProxyObject)
            })
        }))).toEqual({
            name: 'ObjectRecord',
            contents: [
                {name: 'value', type: 'boolean', custom: false},
                {name: 'item', type: 'string', custom: false}
            ]
        })
    })
})
