/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

const {storeAlias} = require('./prepare-record')

const PRIMITIVE_NAMES = {
    StringType: 'string',
    NumberType: 'number',
    BooleanType: 'boolean',
    IntegerType: 'number'
}

const valueTypeInfo = (propertyType) => {
    const nameId = propertyType.nameId()
    // This is not the best way to treat enums but I can't find a
    // better one using the runtime types.
    if (nameId === null) {
        return propertyTypeInfo(propertyType.superTypes()[0]) // eslint-disable-line no-use-before-define
    }
    return {
        type: PRIMITIVE_NAMES[nameId] || nameId,
        custom: false
    }
}

const propertyTypeInfo = (propertyType) => {
    if (propertyType.isValueType()) {
        return valueTypeInfo(propertyType)
    }

    if (propertyType.isUnion()) {
        if (propertyType.leftType().nameId() === 'nil') {
            return Object.assign(
                {nullable: true},
                propertyTypeInfo(propertyType.rightType())
            )
        } else if (propertyType.rightType().nameId() === 'nil') {
            return Object.assign(
                {nullable: true},
                propertyTypeInfo(propertyType.leftType())
            )
        } else {
            console.error('Unions of multiple defined types are currently unimplemented')
        }
    }

    if (propertyType.isArray()) {
        return Object.assign({
            defaultValue: 'Immutable.List()',
            propType: 'PropTypes.instanceOf(Immutable.List)',
            type: propertyType.componentType().nameId()
        })
    }

    if (propertyType.isObject() && propertyType.nameId() === 'object') {
        return {
            type: 'object',
            custom: false
        }
    }

    return {
        type: propertyType.nameId(),
        custom: true
    }
}

const typeToRecord = (type) => {
    const runtimeType = type.runtimeDefinition()
    if (runtimeType.isValueType()) {
        storeAlias(type.name(), PRIMITIVE_NAMES[runtimeType.superTypes()[0].nameId()])
        return null
    }
    return {
        name: type.name(),
        contents: runtimeType.allProperties()
            .map((property) => Object.assign(
                {name: property.nameId()},
                propertyTypeInfo(property.range())
            ))
    }
}

// This function doesn't have much to it, it's not really necessary to test it.
/* istanbul ignore next */
const extractRecords = (types) => types.map(typeToRecord)

module.exports = {valueTypeInfo, extractRecords, typeToRecord, propertyTypeInfo}
