/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

jest.mock('archiver')
const archiver = require('archiver')

jest.mock('git-rev-sync')
const git = require('git-rev-sync')

jest.mock('./file-utils')
const fileUtils = require('./file-utils')

const Utils = require('./utils')

let realFail
beforeEach(() => {
    realFail = Utils.fail
    Utils.fail = jest.fn()
})

afterEach(() => {
    Utils.fail = realFail
})

test('buildObject fails if the file read fails', () => {
    fileUtils.readFileAsync.mockReturnValue(Promise.reject())
    Utils.fail.mockImplementation(() => { throw new Error() })

    return Utils.buildObject()
        .catch(() => {
            expect(Utils.fail).toHaveBeenCalledTimes(1)
        })
})

test('buildObject translates a file into an upload-ready object', () => {
    const mockData = {
        toString: (type) => {
            expect(type).toBe('base64')
            return 'this should be base64 but I\'m lazy'
        }
    }

    fileUtils.readFileAsync.mockReturnValue(Promise.resolve(mockData))

    return Utils.buildObject('test-archive.zip', 'Message!')
        .then((built) => {
            expect(built.message).toBe('Message!')
            expect(built.encoding).toBe('base64')
            expect(built.data).toBe('this should be base64 but I\'m lazy')

            expect(fileUtils.readFileAsync).toHaveBeenCalledTimes(1)
            expect(fileUtils.readFileAsync).toHaveBeenCalledWith('test-archive.zip')
        })
})

test('buildObject defaults the message to an empty string', () => {
    fileUtils.readFileAsync.mockReturnValue(Promise.resolve({toString: () => ''}))

    return Utils.buildObject('test')
        .then((built) => {
            expect(built.message).toBe('')
        })
})

describe('createBundle', () => {
    test('createBundle fails if the build directory doesn\'t exist', () => {
        fileUtils.statAsync.mockReturnValue(Promise.reject())

        Utils.fail.mockReturnValue(Promise.reject())

        return Utils.createBundle('buildDir')
            .catch(() => {
                expect(fileUtils.statAsync).toBeCalledWith('buildDir')
                expect(Utils.fail).toBeCalled()
                expect(Utils.fail.mock.calls[0][0].includes('buildDir')).toBe(true)
            })
    })

    test('createBundle checks if the build directory exists and creates an archive there', () => {
        fileUtils.statAsync.mockReturnValue(Promise.resolve())

        const outputStream = {
            stream: 'stream!',
            on: jest.fn((_, cb) => cb())
        }
        fileUtils.createWriteStream.mockReturnValue(outputStream)

        const archive = {
            on: jest.fn(),
            pipe: jest.fn(),
            bulk: jest.fn(function() { return this }),
            finalize: jest.fn()
        }
        archiver.mockReturnValue(archive)

        return Utils.createBundle('build', 'unitTests', 'dest.tar')
            .then(() => {
                expect(fileUtils.statAsync).toBeCalledWith('build')
                expect(fileUtils.createWriteStream).toBeCalledWith('dest.tar')
                expect(archive.on).toBeCalledWith('error', Utils.fail)
                expect(archive.pipe).toBeCalledWith(outputStream)
                expect(archive.bulk).toHaveBeenCalledTimes(1)
                expect(archive.bulk.mock.calls[0][0]).toEqual([{
                    expand: true,
                    cwd: 'build',
                    src: ['**'],
                    dest: 'unitTests/bld'
                }])
                expect(archive.finalize).toHaveBeenCalledTimes(1)
            })
    })
})

test('getRequestHeaders sets the User-Agent header', () => {
    const result = Utils.getRequestHeaders()

    expect(result['User-Agent']).toMatch(/^progressive-web-sdk#\d+\.\d+\.\d+$/)
})

test('getRequestHeaders copies over headers from the passed object', () => {
    const additionalHeaders = {
        Cryptography: 'none',
        Context: 'testing',
        Connections: 'mocked out'
    }

    const result = Utils.getRequestHeaders(additionalHeaders)

    Object.keys(additionalHeaders).forEach((key) => {
        expect(result[key]).toBe(additionalHeaders[key])
    })
})

test('errorForStatus returns false for 2xx and 3xx statuses', () => {
    [200, 201, 302, 303, 304].forEach((statusCode) => {
        expect(Utils.errorForStatus({statusCode})).toBe(false)
    })
})

test('errorForStatus returns an Error for 4xx and 5xx statuses', () => {
    [400, 401, 403, 404, 500, 503].forEach((statusCode) => {
        expect(Utils.errorForStatus({statusCode})).toBeInstanceOf(Error)
    })
})

describe('readCredentials', () => {
    test('reads the credentials for the given path', () => {
        fileUtils.statAsync.mockReturnValue(Promise.resolve(true))
        fileUtils.readFileAsync.mockReturnValue(Promise.resolve('{"username": "tester", "api_key": "0xCAFEFADE"}'))

        return Utils.readCredentials('.credentials')
            .then((result) => {
                expect(fileUtils.statAsync).toHaveBeenCalledTimes(1)
                expect(fileUtils.statAsync).toHaveBeenCalledWith('.credentials')

                expect(fileUtils.readFileAsync).toHaveBeenCalledWith('.credentials')

                expect(result.username).toBe('tester')
                expect(result.api_key).toBe('0xCAFEFADE')
            })
    })
})

describe('setDefaultMessage', () => {

    test('Bundle message is set to branch and commit hash', () => {
        git.branch.mockClear()
        git.short.mockClear()
        git.branch.mockReturnValueOnce('develop')
        git.short.mockReturnValueOnce('4cd54ec')

        expect(Utils.setDefaultMessage()).toBe('develop: 4cd54ec')
    })

    test('Bundle message defaults properly if git branch fails', () => {
        git.branch.mockImplementationOnce(() => {
            throw new Error('Failwhale')
        })

        expect(Utils.setDefaultMessage()).toBe('Mobify Bundle')
    })

    test('Bundle message defaults properly if git short fails', () => {
        git.short.mockImplementationOnce(() => {
            throw new Error('Failwhale')
        })

        expect(Utils.setDefaultMessage()).toBe('Mobify Bundle')
    })

    test('Test message is printed if we have an ENOENT', () => {
        git.branch.mockImplementationOnce(() => {
            throw {code: 'ENOENT'}
        })
        const consoleLog = console.log
        const mockConsoleLog = jest.fn()
        console.log = mockConsoleLog

        try {
            Utils.setDefaultMessage()
        } finally {
            console.log = consoleLog
        }

        expect(mockConsoleLog).toBeCalled()
        expect(mockConsoleLog.mock.calls[0][0].includes('git init')).toBe(true)
    })
})
