/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

import {
    shouldAsk, isSubscribedToChannel,
    isMessagingSupported
} from './messaging'
import * as constants from '../store/push-messaging/constants'

describe('shouldAsk method', () => {
    const logger = {}
    let shouldAskMethod

    const defaultProps = {
        visitCountdowns: {},
        canSubscribe: false,
        channels: [],
        isSubscribed: false,
        pageCount: 1,
        deferOnDismissal: 3,
        showOnPageCount: 3
    }

    beforeEach(() => {
        logger.log = jest.fn()
        shouldAskMethod = shouldAsk.bind(this, logger)
    })

    test('returns false if `canSubscribe` is false', () => {
        const result = shouldAskMethod(defaultProps)
        expect(logger.log.mock.calls[0][0]).toEqual('Should not ask : Unable to subscribe. Messaging Client is not ready or notification permissions are blocked')
        expect(result).toBe(false)
    })

    test('returns false if `visitCountdown` for `channelName` is > 0', () => {
        const props = {
            ...defaultProps,
            canSubscribe: true,
            visitCountdowns: {
                bar: 3
            },
            channelName: 'bar'
        }
        const result = shouldAskMethod(props)
        expect(logger.log.mock.calls[0][0]).toEqual('Should not ask for channel bar: Deferred until 3 more visit(s)')
        expect(result).toBe(false)
    })

    test('returns false if pageCount % showOnPageCount is greater than 0', () => {
        const props = {
            ...defaultProps,
            canSubscribe: true
        }
        const result = shouldAskMethod(props)
        expect(logger.log.mock.calls[0][0]).toEqual('Should not ask : Waiting for 2 more page visit(s)')
        expect(result).toBe(false)
    })

    test('returns false when already subscribed to this channel', () => {
        const props = {
            ...defaultProps,
            canSubscribe: true,
            isSubscribed: true,
            channels: [constants.DEFAULT_CHANNEL, 'bar']
        }
        const result = shouldAskMethod(props)
        expect(logger.log.mock.calls[0][0]).toEqual('Should not ask : Already subscribed')
        expect(result).toBe(false)
    })

    test('returns true if all conditions are met', () => {
        const props = {
            ...defaultProps,
            canSubscribe: true,
            isSubscribed: true,
            channels: [constants.DEFAULT_CHANNEL],
            channelName: 'bar',
            showOnPageCount: 3,
            pageCount: 3,
            visitCountdowns: {
                'new-deals': 4
            }
        }
        const result = shouldAskMethod(props)
        expect(logger.log.mock.calls[0]).toEqual(['Can ask', 'for channel bar'])
        expect(result).toBe(true)
    })

    test('ignores pageCount changes if alreadyShown is true', () => {
        const props = {
            ...defaultProps,
            canSubscribe: true,
            showOnPageCount: 2,
            pageCount: 3
        }
        const result = shouldAskMethod(props, true)
        expect(result).toBe(true)
    })

    test('returns false when pageCount is insufficient, when alreadyShown is false', () => {
        const props = {
            ...defaultProps,
            canSubscribe: true,
            showOnPageCount: 4,
            pageCount: 3
        }
        const result = shouldAskMethod(props, false)
        expect(logger.log.mock.calls[0][0]).toEqual('Should not ask : Waiting for 1 more page visit(s)')
        expect(result).toBe(false)
    })
})

describe('isSubscribedToChannel method', () => {
    test('returns true if no channel name is provided', () => {
        expect(isSubscribedToChannel(true, ['channel1', 'channel2'])).toBe(true)
    })

    test('returns true if the given channel name exists in channels array', () => {
        expect(isSubscribedToChannel(true, ['channel1', 'channel2'], 'channel1')).toBe(true)
    })

    test('returns false if isSubscribed is false', () => {
        expect(isSubscribedToChannel(false, ['channel1', 'channel2'], 'channel1')).toBe(false)
    })

    test('returns false if channel name does not exist in channels array', () => {
        expect(isSubscribedToChannel(true, ['channel1', 'channel2'], 'channel3')).toBe(false)
    })
})

describe('isMessagingSupported function', () => {
    let windowProgressive
    beforeEach(() => {
        windowProgressive = window.Progressive
        window.Progressive = {}
    })
    afterEach(() => {
        window.Progressive = windowProgressive
    })
    test('returns true only when messaging is enabled and supported', () => {
        window.Progressive = null
        expect(isMessagingSupported()).toBe(false)
        window.Progressive = {}
        expect(isMessagingSupported()).toBe(false)
        window.Progressive.Messaging = {}
        expect(isMessagingSupported()).toBe(false)
        window.Progressive.Messaging.enabled = true
        expect(isMessagingSupported()).toBe(false)
        window.Progressive.Messaging.supported = true
        expect(isMessagingSupported()).toBe(true)
    })
})
