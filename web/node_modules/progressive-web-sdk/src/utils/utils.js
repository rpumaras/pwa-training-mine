/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

// This file contains functions used by the app 'loader.js'. It should be kept
// as small as possible to reduce the size of the loader.

/* istanbul ignore next */
export const noop = () => {}

/**
* Converts a URL to the relative URL
* @param {string} url - the url to be converted (if it's already relative it will be returned as is)
* @param {bool} includeHash - indicates if the URL hash should be included in the relative URL returns
* @param {bool} includeQuery - indicates if the URL query should be included in the relative URL returns
*/
export const extractPathFromURL = (url, includeHash = false, includeQuery = true) => {
    let workingUrl = url

    if (/^\//.test(workingUrl)) {
        // URL is relative, make it a full URL so we can use the same
        // logic below to rebuild the path.
        workingUrl = `http://www.example.com${workingUrl}`
    }

    const urlObject = new URL(workingUrl)

    return `${urlObject.pathname}${includeQuery ? urlObject.search : ''}${includeHash ? urlObject.hash : ''}`
}

/**
 * Converts a full URL to the preferred format for keying the redux store,
 * i.e. the path and query string
 */
export const urlToPathKey = (url) => extractPathFromURL(url, false)

/**
 * Converts a full URL to the preferred format for keying the redux store,
 * i.e. only the path (without query string)
 */
export const urlToBasicPathKey = (url) => extractPathFromURL(url, false, false)

/**
 * Get the major version of Chrome and return it as an integer.
 * If the browser isn't Chrome, return zero.
 * @param userAgent - the userAgent to test
 * @returns {Number}
 */
export const getChromeVersion = (userAgent) => {
    const versionMatch = userAgent.match(/(Chrome|CriOS)\/(\d+)/i)
    const version = versionMatch && parseInt(versionMatch[2])
    return version || 0
}

export const isSamsungBrowser = (userAgent) => {
    const samsungRegex = /SamsungBrowser/i

    const chromeVersion = getChromeVersion(userAgent)

    // Some older Samsung devices have a default browser that's stuck on an old version of Chrome
    // We want to default to the responsive site for these devices
    // We know for sure that Chrome 28 doesn't work so we're using that as the cutoff for now
    const unsupportedChrome = chromeVersion && chromeVersion <= 28

    // Page speed insights uses a chrome 27 user agent, so we need to explicitly support it
    const isPageSpeed = /Google Page Speed Insights/i.test(userAgent)

    return !isPageSpeed && (samsungRegex.test(userAgent) || unsupportedChrome)
}

/**
 * Return true if the given useragent is of a browser running on iOS.
 * We do this to allow detection of all iOS/webkit browsers in one test.
 * @param userAgent - the userAgent to test
 * @returns {Boolean}
 */
export const iOSBrowser = (userAgent) => (
    /(iPad|iPhone|iPod)/g.test(userAgent)
)

export const isFirefoxBrowser = (userAgent) => {
    const firefoxRegex = /Firefox/i
    const iOSFirefoxRegex = /FxiOS/i

    return firefoxRegex.test(userAgent) || iOSFirefoxRegex.test(userAgent)
}

/**
 * Get the major version of Firefox. If the browser isn't Firefox, then
 * return zero
 * @param userAgent - the userAgent to test
 * @returns {Number}
 */
export const getFirefoxVersion = (userAgent) => {
    const versionMatch = userAgent.match(/(Firefox|FxiOS)\/(\d+)/i)
    const version = versionMatch && parseInt(versionMatch[2])
    return version || 0
}

export const preventDesktopSiteFromRendering = () => {
    if (document.querySelectorAll('plaintext').length > 0) {
        // If the plaintext tag is already present in the page, this means that
        // the desktop site has already been prevented from rendering. This
        // is due to the use of an older Mobify tag (pre V8), which inserts
        // the plaintext tag inline.
        return
    }
    document.write('<plaintext style="display: none;">')
}

const hasTriedLoadScript = ({id, src, method}) => {
    const idQuery = id ? `[id="${id}"]` : ''
    return document.querySelectorAll(
        `script${idQuery}` +
        `[src="${src}"]` +
        `[data-load-method="${method}"]`
    ).length > 0
}

let loadScriptCounter = 0
export const loadScript = ({id, src, isAsync = true, docwrite = false, onload, onerror}) => {
    const loadMethod = docwrite ? 'document.write()' : 'DOM'
    if (hasTriedLoadScript({id, src, method: loadMethod})) {
        console.warn(`[mobify.progressive] loadScript() already called for this script. Ignoring call. (method='${loadMethod}' id='${id}' src='${src}')`)
        return
    }

    if (onload && typeof onload !== 'function') {
        throw new Error(`loadScript()'s 'onload' parameter must be a function but was passed a ${typeof onload}!`)
    }

    if (onerror && typeof onerror !== 'function') {
        throw new Error(`loadScript()'s 'onerror' parameter must be a function but was passed a ${typeof onerror}!`)
    }

    // TODO: Check for navigator.connection. Need Android for this.
    /* istanbul ignore next */
    if (docwrite && document.readyState === 'loading') {
        window.Mobify = window.Mobify || {}

        let onLoadString = ''
        let onErrorString = ''

        if (typeof onload === 'function') {
            window.Mobify.scriptOnLoads = Object.assign({}, window.Mobify.scriptOnLoads, {
                [loadScriptCounter]: onload
            })
            // Space prefix is important for valid rendered HTML
            onLoadString = ` onload="window.Mobify.scriptOnLoads['${loadScriptCounter}'] && window.Mobify.scriptOnLoads['${loadScriptCounter}']()"`
        }

        if (typeof onerror === 'function') {
            window.Mobify.scriptOnErrors = Object.assign({}, window.Mobify.scriptOnErrors, {
                [loadScriptCounter]: onerror
            })
            // Space prefix is important for valid rendered HTML
            onErrorString = ` onerror="window.Mobify.scriptOnErrors['${loadScriptCounter}'] && window.Mobify.scriptOnErrors['${loadScriptCounter}']()"`
        }

        document.write(`<script id='${id}' src='${src}' data-load-method='${loadMethod}' charset='utf-8'${onLoadString}${onErrorString}></script>`)
        loadScriptCounter++
    } else {
        const script = document.createElement('script')

        // Setting UTF-8 as our encoding ensures that certain strings (i.e.
        // Japanese text) are not improperly converted to something else. We
        // do this on the vendor scripts also just in case any libs we
        // import have localized strings in them.
        script.charset = 'utf-8'
        script.async = isAsync
        if (id) {
            script.id = id
        }
        script.src = src
        script.dataset.loadMethod = loadMethod

        /* istanbul ignore next */
        if (typeof onload === 'function') {
            script.onload = onload
        }
        /* istanbul ignore next */
        if (typeof onerror === 'function') {
            script.onerror = onerror
        }

        document.getElementsByTagName('head')[0].appendChild(script)
    }
}

export const loadScriptAsPromise = ({id, src, onload, isAsync = true, rejectOnError = true}) => (
    new Promise((resolve, reject) => {
        const resolver = () => {
            /* istanbul ignore else */
            if (typeof onload === 'function') {
                onload()
            }
            resolve()
        }

        loadScript({
            id,
            src,
            onload: resolver,
            isAsync,
            onerror: rejectOnError ? reject : /* istanbul ignore next */ resolve
        })
    })
)

export const documentWriteSupported = () => {
    // In Chrome, "Good 2G" has a download max of 0.439453125, thus we have
    // chosen our benchmark of 0.44 to determine if the connection is
    // poor. We have not specifically checked the connection type (ie cellular)
    // because in the future according to
    // https://developers.google.com/web/updates/2016/08/removing-document-write
    // the plan is to also have people on slow WiFi connections unable to
    // load the page via document.write.
    if (navigator.connection && navigator.connection.downlinkMax <= 0.44) {
        return false
    }
    return true
}

/**
 * Verify if page number is valid
 * If valid, return page number
 * If not valid, return first or last page number
 * @param {number} page - input page parameter to be verified
 * @param {number} count - optional parameter indicate total page count
 */
export const validatePageNumber = (page, count = false) => {
    page = parseInt(page)
    if (isNaN(page) || page < 1) {
        return 1
    }
    if (count && page > count) {
        return count
    }
    return page
}

/*
 * Checks if the given storage type is available.
 * @param {Storage} storage
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Storage
 */
const isStorageAvailable = (storage) => {
    const x = '__test_key__'
    try {
        storage.setItem(x, x)

        // Test retrieving the set item
        if (x !== storage.getItem(x)) {
            throw new Error(`${typeof storage} is not supported in this environment!`)
        }

        return true
    } catch (e) {
        return false
    } finally {
        try {
            storage.removeItem(x)
        } catch (e) { /* Swallow errors here */ }
    }
}

/**
 * Checks if local storage is available in the current environment.
 */
export const isLocalStorageAvailable = () => {
    return isStorageAvailable(localStorage)
}

/**
 * Checks if session storage is available in the current environment.
 */
export const isSessionStorageAvailable = () => {
    return isStorageAvailable(sessionStorage)
}

/**
 * Checks if the browser supports Messaging - specifically, whether it supports
 * Mobify messaging, rather than W3C push notifications in general. Not all
 * browsers that support push are supported by Mobify, since the support for
 * the standards has evolved over time, and some older browsers have quirks
 * that mean we consider them unsupported.
 *
 * This function is Messaging-specific, but it's provided here in this SDK
 * file so that it's usable by the loader, without requiring the loader to
 * import yet another SDK module.
 *
 * This function will work for a PWA and also in non-PWA (standalone) mode,
 * so it will report true for browsers other than Chrome.
 *
 * The checks here are a combination of browser capability checks and version
 * checks for specific browsers. The minimum versions of browsers should align
 * with the supported browser version in the Messaging server file
 * https://github.com/mobify/pusheen/blob/master/backend/config.py
 *
 * This function does not check for Safari APNS push messaging support.
 *
 * @param userAgent - the userAgent to test - used for testing
 * @returns {Boolean}
 **/
export const browserSupportsMessaging = (userAgent) => {
    // Browser capability checks
    if (!(
        // W3C Push Messaging (https://www.w3.org/TR/push-api/)
        // requires that the browser support service workers. Much
        // of the Push API is only available to service workers, and
        // this function is intended to work client-side, so we can't
        // check for full availability. However, if there's no
        // service worker support, there can be no Push API.
        navigator.serviceWorker &&
        // If Notification isn't present, we can't
        // check for or request permission to show notifications.
        window.Notification
    )) {
        return false
    }

    // The browser supports service workers and the Notification
    // interface. However, the API has evolved over time, and support
    // is not always consistent across browsers, so we need to check
    // the browser name and minimum version. The minimum version numbers
    // here must match values in the Messaging backend (backend/config.js)
    const ua = userAgent || navigator.userAgent

    // Exclude all iOS webkit browsers. As of iOS 10, they will also fail
    // the service-worker/Notification test above, but here we're guarding
    // against those features appearing in iOS before we have time to test
    // Messaging support.
    if (iOSBrowser(ua)) {
        return false
    }

    // Check for Chrome
    let version = getChromeVersion(ua)
    if (version && version >= 46) {
        return true
    }

    // Check for Firefox
    version = getFirefoxVersion(ua)
    if (version && version >= 46) {
        return true
    }

    // This is not a browser that we explicitly support, so
    // the safest return is false.
    return false
}

/**
 * This util is designed for use only when the app first launches in standalone mode.
 * The window.matchMedia check may fail on some versions of chrome even
 * if the app is in standalone mode and after the app launches and the user has
 * navigated elsewhere the URL may not contain ?homescreen=1 anymore.
 *
 * Using this util outside of when the app launches may produce false negatives
 *
 * If you need to check if the app is in standalone mode use the key stored
 * in the app branch of the redux store instead of this util.
 */
export const isStandalone = () => /homescreen=1/.test(window.location.href) || window.matchMedia('(display-mode: standalone)').matches
