/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

import {shallow, mount} from 'enzyme'
import React from 'react'

import Sheet from './index'
import SheetContent from './sheet-content'

const sheetClassName = '.pw-sheet'
const wrapperClassName = '.pw-sheet__wrapper'
const prerenderClassName = '.pw-sheet__prerendered-children'

// Mock `requestAnimationFrame` for tests run using jsDOM
global.requestAnimationFrame = global.window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 0)
}

/* eslint-disable newline-per-chained-call */

describe('SheetContent', () => {
    test('renders without errors', () => {
        const wrapper = mount(<SheetContent {...Sheet.defaultProps} />)
        expect(wrapper.length).toBe(1)
    })

    test('includes the component class name with no className prop', () => {
        const wrapper = shallow(<SheetContent {...Sheet.defaultProps} />)

        expect(wrapper.hasClass('pw-sheet')).toBe(true)
    })

    test('does not render an \'undefined\' class with no className', () => {
        const wrapper = shallow(<SheetContent {...Sheet.defaultProps} />)

        expect(wrapper.hasClass('undefined')).toBe(false)
    })

    test('renders the contents of the className prop if present', () => {
        [
            'test',
            'test another'
        ].forEach((name) => {
            const wrapper = shallow(<SheetContent {...Sheet.defaultProps} className={name} />)

            expect(wrapper.hasClass(name)).toBe(true)
        })
    })

    test('renders the header content if passed', () => {
        const props = {
            ...Sheet.defaultProps,
            headerContent: (<div id="test">Test</div>)
        }
        const wrapper = shallow(<SheetContent {...props} />)

        expect(wrapper.find('.pw-sheet__inner').childAt(0).hasClass('pw-sheet__header')).toBe(true)
        expect(wrapper.find('.pw-sheet__header').length).toBe(1)
        expect(wrapper.find('.pw-sheet__header > #test').length).toBe(1)
        expect(wrapper.find('#test').text()).toBe('Test')
    })

    test('renders the title if passed', () => {
        const props = {
            ...Sheet.defaultProps,
            title: 'SheetContent Title'
        }
        const wrapper = shallow(<SheetContent {...props} />)

        expect(wrapper.find('.pw-sheet__header').length).toBe(1)
        expect(wrapper.find('.pw-sheet__header > h1').text()).toBe(props.title)
    })

    test('renders the footer content if passed', () => {
        const props = {
            ...Sheet.defaultProps,
            footerContent: (<div id="test">Test</div>)
        }
        const wrapper = shallow(<SheetContent {...props} />)

        expect(wrapper.find('.pw-sheet__inner').childAt(1).hasClass('pw-sheet__footer')).toBe(true)
        expect(wrapper.find('.pw-sheet__footer').length).toBe(1)
        expect(wrapper.find('.pw-sheet__footer > #test').length).toBe(1)
        expect(wrapper.find('#test').text()).toBe('Test')
    })

    test('clicking on the mask calls onDismiss', () => {
        const props = {
            ...Sheet.defaultProps,
            onDismiss: jest.fn()
        }
        const wrapper = mount(<SheetContent {...props} />)

        expect(wrapper.find('.pw-sheet__mask').length).toBe(1)
        expect(props.onDismiss).not.toBeCalled()
        wrapper.find('.pw-sheet__mask').simulate('click')
        expect(props.onDismiss).toBeCalled()
    })

    test('clicking directly on the wrapper calls onDismiss', () => {
        const props = {
            ...Sheet.defaultProps,
            onDismiss: jest.fn()
        }
        const wrapper = mount(<SheetContent {...props} />)

        expect(wrapper.find('.pw-sheet__wrapper').length).toBe(1)
        expect(props.onDismiss).not.toBeCalled()
        wrapper.find('.pw-sheet__wrapper').simulate('click')
        expect(props.onDismiss).toBeCalled()
    })

    test('clicking on the inner content does not call onDismiss', () => {
        const props = {
            ...Sheet.defaultProps,
            onDismiss: jest.fn()
        }
        const wrapper = mount(<SheetContent {...props} />)

        expect(wrapper.find('.pw-sheet__inner').length).toBe(1)
        expect(props.onDismiss).not.toBeCalled()
        wrapper.find('.pw-sheet__inner').simulate('click')
        expect(props.onDismiss).not.toBeCalled()
    })

    test('renders in center of screen if effect is modal-center', () => {
        const props = {
            ...Sheet.defaultProps,
            effect: 'modal-center'
        }
        const wrapper = mount(<SheetContent {...props} />)
        let style = wrapper.find(wrapperClassName).prop('style')
        expect(style.top).toBe('10%')
        expect(style.right).toBe('10%')
        expect(style.bottom).toBe('10%')
        expect(style.left).toBe('10%')
        expect(style.transform).toBe('scale(0)')
        wrapper.setState({phase: 'enterActive'})
        wrapper.update()
        style = wrapper.find(wrapperClassName).prop('style')
        expect(style.transform).toBe('scale(1)')
    })

    describe('.onInnerScroll', () => {
        beforeAll(() => {
            jest.useFakeTimers()
        })

        afterAll(() => {
            jest.useRealTimers()
        })

        let wrapper
        let instance
        let mockScroll
        beforeEach(() => {
            wrapper = mount(<SheetContent {...Sheet.defaultProps} />)
            instance = wrapper.instance()
            mockScroll = jest.fn(instance.onInnerScroll)
            instance.onInnerScroll = mockScroll
            wrapper.update()
        })

        const simulateScrollAndExpectToBe = (expected) => {
            mockScroll.mockClear()
            wrapper.find(wrapperClassName).simulate('scroll')
            expect(mockScroll).toHaveBeenCalled()
            jest.runAllTimers()
            expect(instance.wrapperEl.scrollTop).toBe(expected)
        }

        test('scrolling to 0px on iOS', () => {
            instance.isIOS = true
            instance.wrapperEl.scrollTop = 0
            simulateScrollAndExpectToBe(1)
        })

        test('scrolling to 1px on iOS', () => {
            instance.isIOS = true
            instance.wrapperEl.scrollTop = 1
            simulateScrollAndExpectToBe(1)
        })

        test('scrolling to 100px on iOS', () => {
            instance.isIOS = true
            instance.wrapperEl.scrollTop = 100
            Object.defineProperty(instance.wrapperEl, 'scrollHeight', {get: () => 150})
            Object.defineProperty(instance.wrapperEl, 'offsetHeight', {get: () => 50})
            simulateScrollAndExpectToBe(99)
        })

        test('scrolling to 50px on iOS', () => {
            instance.isIOS = true
            instance.wrapperEl.scrollTop = 50
            Object.defineProperty(instance.wrapperEl, 'scrollHeight', {get: () => 150})
            Object.defineProperty(instance.wrapperEl, 'offsetHeight', {get: () => 50})
            simulateScrollAndExpectToBe(50)
        })

        test('scrolling to 0px on non-iOS', () => {
            instance.isIOS = false
            instance.wrapperEl.scrollTop = 0
            simulateScrollAndExpectToBe(0)
        })
    })
})

describe('Sheet', () => {
    test('renders without errors', () => {
        const wrapper = mount(<Sheet />)
        expect(wrapper.length).toBe(1)
    })

    test('does not render children when closed', () => {
        const children = <div><p>This is child</p></div>
        const wrapper = mount(
            <Sheet open={false}>
                {children}
            </Sheet>
        )
        const sheetContents = wrapper.find(sheetClassName)
        expect(sheetContents.length).toBe(0)
        expect(wrapper.contains(children)).toBe(false)
    })

    test('renders children when open', () => {
        const children = <div><p>This is child</p></div>
        const wrapper = mount(
            <Sheet open={true}>
                {children}
            </Sheet>
        )

        const sheetContents = wrapper.find(sheetClassName)
        expect(sheetContents.length).toBe(1)

        const sheetContent = sheetContents.first()
        expect(sheetContent.contains(children)).toBe(true)
    })

    test('render children when closed and prerender is true', () => {
        const children = <div><p>This is a pre-rendered child</p></div>
        const wrapper = mount(
            <Sheet prerender={true} open={false}>
                {children}
            </Sheet>
        )

        const prerenderedWrapper = wrapper.find(prerenderClassName)
        expect(prerenderedWrapper.length).toBe(1)

        const prerenderedChildren = prerenderedWrapper.first()
        expect(prerenderedChildren.contains(children)).toBe(true)
    })

    test('supports callbacks signalling opening/closing transitions', () => {
        const duration = 50
        const timeOut = duration * 3

        const onBeforeOpen = jest.fn()
        const onOpen = jest.fn()
        const onBeforeClose = jest.fn()
        const onClose = jest.fn()

        const wrapper = mount(
            <Sheet
                onBeforeOpen={onBeforeOpen}
                onOpen={onOpen}
                onBeforeClose={onBeforeClose}
                onClose={onClose}
                open={false}
                duration={duration}
            />
        )

        // Sanity check - rendered, but closed initially
        expect(onBeforeOpen).not.toBeCalled()
        expect(onOpen).not.toBeCalled()
        expect(onBeforeClose).not.toBeCalled()
        expect(onClose).not.toBeCalled()

        const doOpen = () => {
            return new Promise((resolve) => {
                wrapper.setProps({open: true})

                expect(onBeforeOpen).toHaveBeenCalledTimes(1)
                expect(onOpen).not.toBeCalled()

                setTimeout(resolve, timeOut)
            })
        }

        const afterOpen = () => {
            expect(onBeforeOpen).toHaveBeenCalledTimes(1)
            expect(onOpen).toHaveBeenCalledTimes(1)
            expect(onBeforeClose).not.toBeCalled()
            expect(onClose).not.toBeCalled()
        }

        const doClose = () => {
            return new Promise((resolve) => {
                wrapper.setProps({open: false})

                expect(onBeforeClose).toHaveBeenCalledTimes(1)
                expect(onClose).not.toBeCalled()

                setTimeout(resolve, timeOut)
            })
        }

        const afterClose = () => {
            expect(onBeforeOpen).toHaveBeenCalledTimes(1)
            expect(onOpen).toHaveBeenCalledTimes(1)
            expect(onBeforeClose).toHaveBeenCalledTimes(1)
            expect(onClose).toHaveBeenCalledTimes(1)
        }

        return doOpen()
            .then(afterOpen)
            .then(doClose)
            .then(afterClose)

    })
})
