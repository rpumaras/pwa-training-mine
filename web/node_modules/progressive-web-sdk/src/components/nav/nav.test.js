/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

import {mount, shallow} from 'enzyme'
import React from 'react'

import Nav from './index.jsx'


describe('Nav renders without errors', () => {

    test('with no props', () => {
        const wrapper = mount(<Nav />)
        expect(wrapper.length).toBe(1)
    })

    test('with a single child', () => {
        const path = '/'
        const root = {title: 'root', path}
        const wrapper = mount(<Nav root={root} path={path} />)
        expect(wrapper.length).toBe(1)
    })

    test('with multiple children', () => {
        const path = '/'
        const root = {title: 'root', path, children: [
            {title: 'one', path: '/thing-one/'},
            {title: 'two', path: '/thing-two/'},
        ]}
        const wrapper = mount(<Nav root={root} path={path} />)
        expect(wrapper.length).toBe(1)
    })

    test('allowing arbitrary content in the menu', () => {
        const wrapper = mount(<Nav><h1>This has nothing to do with the nav!</h1></Nav>)
        expect(wrapper.html()).toBe('<div class="pw-nav"><h1>This has nothing to do with the nav!</h1></div>')
    })
})

/* eslint-disable newline-per-chained-call */
test('includes the component class name with no className prop', () => {
    const wrapper = shallow(<Nav />)

    expect(wrapper.prop('className').startsWith('pw-nav')).toBe(true)
})

test('does not render an \'undefined\' class with no className', () => {
    const wrapper = shallow(<Nav />)

    expect(wrapper.prop('className').includes('undefined')).toBe(false)
})

test('renders the contents of the className prop if present', () => {
    const name = 'name'
    const wrapper = shallow(<Nav className={name} />)
    expect(wrapper.prop('className').includes(name)).toBe(true)
})


describe('maps path names to nodes in the nav', () => {

    test('for an undefined root', () => {
        expect(Nav.mapNodes(undefined)).toEqual({})
    })

    test('for a root with no children', () => {
        const root = {title: 'root', path: '/'}
        expect(Nav.mapNodes(root)).toEqual({'/': {depth: 0, node: root, parent: root}})
    })

    test('for a root with children', () => {
        const child = {title: 'child', path: '/child/'}
        const root = {title: 'root', path: '/', children: [
            child
        ]}
        expect(Nav.mapNodes(root)).toEqual({
            '/': {depth: 0, node: root, parent: root},
            '/child/': {depth: 1, node: child, parent: root},
        })
    })

    test('throwing an exception if paths are not unique', () => {
        const child1 = {title: 'c', path: '/child/'}
        const child2 = {title: 'c', path: '/child/'}
        const root = {title: 'root', path: '/', children: [
            child1,
            child2
        ]}
        const doMap = () => {
            Nav.mapNodes(root)
        }
        expect(doMap).toThrow('Each NavItem must have a unique "path" prop. Path "/child/" appeared twice.')
    })
})


describe('allows navigation through the navigation tree', () => {

    test('moving one level up in the tree', () => {
        const root = {title: 'root', path: '/', children: [
            {title: 'c1', path: '/child-1/'},
            {title: 'c2', path: '/child-2/'},
        ]}
        const onPathChange = jest.fn()
        const wrapper = shallow(
            <Nav
                root={root}
                path="/child-2/"
                onPathChange={onPathChange} />
        )
        const instance = wrapper.instance()
        instance.goBack()
        expect(onPathChange).toHaveBeenCalledTimes(1)
        expect(onPathChange).toHaveBeenLastCalledWith('/', false)
    })

    test('going to an arbitrary node by path', () => {
        const root = {title: 'root', path: '/', children: [
            {title: 'c1', path: '/child-1/'},
            {title: 'c2', path: '/child-2/'},
        ]}
        const onPathChange = jest.fn()
        const wrapper = shallow(
            <Nav
                root={root}
                path="/child-2/"
                onPathChange={onPathChange} />
        )
        const instance = wrapper.instance()
        instance.goToPath('/child-1/')
        expect(onPathChange).toHaveBeenCalledTimes(1)
        expect(onPathChange).toHaveBeenLastCalledWith('/child-1/', true)
    })

    test('ignores requests for invalid paths', () => {
        const root = {title: 'root', path: '/', children: [
            {title: 'c1', path: '/child-1/'},
            {title: 'c2', path: '/child-2/'},
        ]}
        const onPathChange = jest.fn()
        const wrapper = shallow(
            <Nav
                root={root}
                path="/child-2/"
                onPathChange={onPathChange} />
        )
        const instance = wrapper.instance()
        instance.goToPath('/invalid/')
        expect(onPathChange).toHaveBeenCalledTimes(0)
    })
})

test('revises its node map if a new root is passed', () => {
    const root1 = {title: 'root', path: '/'}
    const root2 = {title: 'root', path: '/', children: [
        {title: 'c1', path: '/child-1/'},
        {title: 'c2', path: '/child-2/'},
    ]}

    const wrapper = mount(<Nav root={root1} />)

    expect(wrapper.state('nodes')).toEqual({
        '/': {depth: 0, node: root1, parent: root1}
    })

    wrapper.setProps({root: root2})

    expect(wrapper.state('nodes')).toEqual({
        '/': {depth: 0, node: root2, parent: root2},
        '/child-1/': {depth: 1, node: root2.children[0], parent: root2},
        '/child-2/': {depth: 1, node: root2.children[1], parent: root2}
    })
})

test('does not revise its node map if other props change', () => {
    const root = {title: 'root', path: '/'}

    const wrapper = mount(<Nav root={root} />)

    expect(wrapper.state('nodes')).toEqual({
        '/': {depth: 0, node: root, parent: root}
    })

    wrapper.setProps({className: 'test'})

    expect(wrapper.state('nodes')).toEqual({
        '/': {depth: 0, node: root, parent: root}
    })
})

test('.getDerivedState returns the correct direction as action', () => {
    const root = {title: 'root', path: '/', children: [
        {title: 'c1', path: '/child-1/', children: [
            {title: 'c2', path: '/child-1/child-2/', children: [{}]}
        ]}
    ]}
    const wrapper = mount(<Nav root={root} path="/child-1/" />)

    expect(wrapper.instance().getDerivedState(
        wrapper.props(), {
            ...wrapper.props(),
            path: '/child-1/child-2/'
        }).action)
        .toBe('descending')

    expect(wrapper.instance().getDerivedState(
        wrapper.props(), {
            ...wrapper.props(),
            path: '/'
        }).action)
        .toBe('ascending')

})
