'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `Lockup` is used to stop the user from being able to scroll the page.
 * Normally, it should wrap around your main app container.
 * To lock the page, set the `locked` prop to true.
 * To unlock the page, set `locked` to false.
 *
 * @example ./DESIGN.md
 */
var Lockup = function (_React$Component) {
    (0, _inherits3.default)(Lockup, _React$Component);

    function Lockup(props) {
        (0, _classCallCheck3.default)(this, Lockup);

        // Determine if we are in mobile safari, we need this to apply a scroll fix.
        // TODO: This should be a utility within the SDK
        var _this = (0, _possibleConstructorReturn3.default)(this, (Lockup.__proto__ || (0, _getPrototypeOf2.default)(Lockup)).call(this, props));

        _this.isIOS = !!navigator.userAgent.match(/Version\/([\d.]+)([^S](Safari)|[^M]*(Mobile)[^S]*(Safari))/);

        _this.state = {};

        _this.lock = _this.lock.bind(_this);

        _this.body = document.body;
        return _this;
    }

    (0, _createClass3.default)(Lockup, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.locked) {
                this.lock();
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            if (this.props.locked && !prevProps.locked) {
                this.lock();
            } else if (!this.props.locked && prevProps.locked) {
                this.unlock();
            }
        }
    }, {
        key: 'lock',
        value: function lock() {
            var scrollPosition = window.scrollY;

            var lockStyles = void 0;

            if (this.isIOS) {
                // On iOS, we lock the height of the element's body wrapping div as well
                // as do some scrolling magic to make sure forms don't jump the page
                // around when they're focused.

                this.body.style.marginTop = '0';
                this.body.style.marginBottom = '0';

                lockStyles = {
                    position: 'relative',
                    height: window.innerHeight + 'px'
                };

                this.container.scrollTop = scrollPosition;
            } else {
                // On Chrome, we can get away with fixing the position of the html
                // and moving it up to the equivalent of the scroll position
                // to lock scrolling.

                lockStyles = {
                    position: 'fixed',
                    top: scrollPosition * -1
                };
            }

            this.setState({
                scrollPosition: scrollPosition,
                style: lockStyles
            });
        }
    }, {
        key: 'unlock',
        value: function unlock() {
            var _this2 = this;

            if (this.isIOS) {
                this.body.style.marginTop = '';
                this.body.style.marginBottom = '';
            }

            this.setState({ style: {} }, function () {
                window.scrollTo(0, _this2.state.scrollPosition);
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var _props = this.props,
                children = _props.children,
                className = _props.className,
                locked = _props.locked;
            var style = this.state.style;


            var classes = (0, _classnames2.default)('pw-lockup', {
                'pw--is-locked': locked
            }, className);

            return _react2.default.createElement(
                'div',
                {
                    className: classes,
                    style: style,
                    ref: function ref(el) {
                        _this3.container = el;
                    }
                },
                children
            );
        }
    }]);
    return Lockup;
}(_react2.default.Component); /* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Lockup.propTypes = {
    /**
     * The children to be locked. Usually, you'll wrap Lockup around your app container
     */
    children: _propTypes2.default.node.isRequired,

    /**
     * Adds values to the `class` attribute of the root element
     */
    className: _propTypes2.default.string,

    /**
     * Indicates whether the children should be locked
     */
    locked: _propTypes2.default.bool
};

exports.default = Lockup;