'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isInteger = require('babel-runtime/core-js/number/is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _static = require('inline-style-prefixer/static');

var _static2 = _interopRequireDefault(_static);

var _carouselButton = require('./partials/carousel-button');

var _carouselButton2 = _interopRequireDefault(_carouselButton);

var _carouselPip = require('./partials/carousel-pip');

var _carouselPip2 = _interopRequireDefault(_carouselPip);

var _propTypeUtils = require('../../prop-type-utils');

var _dataObjects = require('../../analytics/data-objects/');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

var DIRECTION_RIGHT = 'right';
var DIRECTION_LEFT = 'left';

var hasTouch = function hasTouch() {
    return !!('ontouchstart' in window);
};

var getKey = function getKey(index) {
    return 'slide-' + index;
};

var getCursorPosition = function getCursorPosition(e) {
    return hasTouch() ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
};

var preventDefault = function preventDefault(e) {
    return e.preventDefault();
};

/**
 * Related component:
 *
 * * [CarouselItem](#!/CarouselItem)
 *
 * `Carousel` is used to display a series of content (carouselItem).
 * It only shows one item at a time and allows users to cycle
 * through the items by swiping left/right or using next/previous button
 *
 * @example ./DESIGN.md
 */

var Carousel = function (_React$PureComponent) {
    (0, _inherits3.default)(Carousel, _React$PureComponent);

    function Carousel(props) {
        (0, _classCallCheck3.default)(this, Carousel);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Carousel.__proto__ || (0, _getPrototypeOf2.default)(Carousel)).call(this, props));

        _this.state = (0, _extends3.default)({}, _this.calculateIndexes(props.currentSlide || 0), { // Easy way to populate the prev/cur/next indexes
            dragging: false,
            dragStartX: 0,
            dragStartY: 0,
            deltaX: 0,
            deltaY: 0,
            deltaXPercent: 0,
            isScrollingPast: false,
            itemWidth: 0
        });

        _this.moveComplete = _this.moveComplete.bind(_this);
        _this.onPreviousHandler = _this.onPreviousHandler.bind(_this);
        _this.onNextHandler = _this.onNextHandler.bind(_this);
        _this.updateItemWidth = _this.updateItemWidth.bind(_this);

        _this.eventHandlers = hasTouch() ? {
            onTouchStart: _this.onDownHandler.bind(_this),
            onTouchMove: _this.onTouchMoveHandler.bind(_this),
            onTouchEnd: _this.onUpHandler.bind(_this),
            onTouchCancel: _this.onLeaveHandler.bind(_this)
        } : {
            onMouseDown: _this.onMouseDownHandler.bind(_this),
            onMouseMove: _this.onMouseMoveHandler.bind(_this),
            onMouseUp: _this.onMouseUpHandler.bind(_this),
            onMouseLeave: _this.onLeaveHandler.bind(_this)
        };
        return _this;
    }

    (0, _createClass3.default)(Carousel, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.updateItemWidth();

            window.addEventListener('resize', this.updateItemWidth);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            window.removeEventListener('resize', this.updateItemWidth);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(newProps) {
            var useCurrentSlideProp = newProps.currentSlide >= 0;
            // The currentSlide prop is for when the user wants to take manual
            // control over the carousel's internal state. For example: making it
            // possible to change slides using the redux store.
            var currentIndex = useCurrentSlideProp ? newProps.currentSlide : this.state.currentIndex;
            var newLength = newProps.children.length;

            // Update the cur/prev/next indexes because CarouselItems length has changed
            if (newLength !== this.props.children.length) {
                this.setState((0, _extends3.default)({}, this.calculateIndexes(currentIndex, newLength)));
            }

            // Update the indexes because a new currentIndex has been provided
            var oldCurrentSlide = this.props.currentSlide;
            var newCurrentSlide = newProps.currentSlide;
            if (newCurrentSlide !== oldCurrentSlide) {
                this.moveTo(newCurrentSlide);
            }
        }
    }, {
        key: 'updateItemWidth',
        value: function updateItemWidth() {
            // Item width is used to determine how much to slide over when
            // cycling through the slides
            // This is a sanity check and thus difficult to make fail in tests
            /* istanbul ignore else */
            if (this._innerWrapper && this._innerWrapper.firstChild) {
                this.setState({
                    itemWidth: this._innerWrapper.firstChild.clientWidth
                });
            }
        }
    }, {
        key: 'calculateIndex',
        value: function calculateIndex(position, length) {
            var len = length || _react2.default.Children.count(this.props.children);

            // Always return a value within the array bounds. This
            // accounts for when the current position is either 0 or
            // length - 1.
            return position < 0 ? (len - Math.abs(position) % len) % len : position % len;
        }
    }, {
        key: 'calculateIndexes',
        value: function calculateIndexes(position, length) {
            // Calculate the array index for the current item, as well as the previous and next.
            //
            // Optionally called with `length` when indices need to be recalculated due to number of
            // carousel children changing
            return {
                currentIndex: this.calculateIndex(position, length),
                prevIndex: this.calculateIndex(position - 1, length),
                nextIndex: this.calculateIndex(position + 1, length)
            };
        }
    }, {
        key: 'move',
        value: function move(direction) {
            var itemWidth = this.state.itemWidth;

            var newDeltaX = (direction === DIRECTION_LEFT ? 1 : -1) * itemWidth;

            this.setState({
                animate: true,
                deltaX: newDeltaX
            });
        }
    }, {
        key: 'moveComplete',
        value: function moveComplete() {
            // Update the current index.
            var _state = this.state,
                currentIndex = _state.currentIndex,
                deltaX = _state.deltaX;
            var _props = this.props,
                currentSlide = _props.currentSlide,
                onSlideMove = _props.onSlideMove;

            // Disabled animation for next drag.

            this.setState({ animate: false });

            // Return if we haven't moved (user didn't move passed the threshold and was animated back to
            // the deltaX = 0 position).
            if (!deltaX) {
                return;
            }

            // Determine last move by checking the current deltaX value (was moved left or right)
            var index = void 0;
            if ((0, _isInteger2.default)(currentSlide) && currentSlide !== currentIndex) {
                index = currentSlide;
            } else {
                index = currentIndex + (deltaX < 0 ? 1 : -1);
            }

            // Update the indexes and reset the content panel to it's original position.
            var newIndexes = this.calculateIndexes(index);

            this.setState((0, _extends3.default)({}, newIndexes, {
                deltaX: 0
            }), function () {
                // Execute onSlideMove to trigger any listening callbacks, passing it
                // the current index.
                onSlideMove(newIndexes.currentIndex);
            });
        }
    }, {
        key: 'moveTo',
        value: function moveTo(position) {
            var _state2 = this.state,
                itemWidth = _state2.itemWidth,
                currentIndex = _state2.currentIndex;

            var newDeltaX = (currentIndex - position) * itemWidth;

            this.setState({
                animate: true,
                deltaX: newDeltaX
            });
        }
    }, {
        key: 'canMove',
        value: function canMove(direction) {
            var _props2 = this.props,
                children = _props2.children,
                allowLooping = _props2.allowLooping;
            var currentIndex = this.state.currentIndex;

            var slideCount = _react2.default.Children.count(children);

            // If we only have a single slide, it's safe to assume we shouldn't move
            if (slideCount === 1) {
                return false;
            }

            // Determine if you can make a move in the given direction, this is used
            // for both disabling swiping and controls when not looping and you are
            // at the beginning or end of the item array.
            return allowLooping || direction === DIRECTION_LEFT && currentIndex > 0 || direction === DIRECTION_RIGHT && currentIndex !== slideCount - 1;
        }
    }, {
        key: 'onUpHandler',
        value: function onUpHandler() {
            var moveThreshold = this.props.moveThreshold;
            var deltaX = this.state.deltaX;


            this.setState({
                dragging: false,
                isScrollingPast: false
            });

            // After drag is complete, allow app to be scrollable again
            document.ontouchstart = null;
            document.ontouchmove = null;

            // If there is no drag amount, return.
            if (!deltaX || Math.abs(deltaX) < moveThreshold) {
                this.setState({
                    animate: !!deltaX, // Only animate when move is greater than 0.
                    deltaX: 0
                });

                return;
            }
            // We have a valid drag, so move one step in the direction of the drag.
            this.move(deltaX < 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);

            if (window.Progressive) {
                window.Progressive.analytics.send({
                    subject: _dataObjects.UI_SUBJECT.user,
                    action: _dataObjects.UI_ACTION.swipe,
                    object: _dataObjects.UI_OBJECT.element,
                    name: _dataObjects.UI_NAME.carousel,
                    content: deltaX < 0 ? _dataObjects.UI_NAME.next : _dataObjects.UI_NAME.previous
                });
            }
        }
    }, {
        key: 'onDownHandler',
        value: function onDownHandler(e) {
            var animate = this.state.animate;

            // Disallow dragging when animating a move, this should be fixed in
            // a future release.

            if (animate) {
                e.preventDefault();
                return;
            }

            this.setState({
                animate: false,
                dragStartX: getCursorPosition(e.nativeEvent).x,
                dragStartY: getCursorPosition(e.nativeEvent).y
            });
        }
    }, {
        key: 'onMoveHandler',
        value: function onMoveHandler(e) {
            var dragThreshold = this.props.dragThreshold;
            var _state3 = this.state,
                dragging = _state3.dragging,
                dragStartX = _state3.dragStartX,
                dragStartY = _state3.dragStartY,
                isScrollingPast = _state3.isScrollingPast;

            var deltaX = getCursorPosition(e.nativeEvent).x - dragStartX;
            var deltaY = getCursorPosition(e.nativeEvent).y - dragStartY;
            var isUnderDragThreshold = Math.abs(deltaX) < dragThreshold;

            // If we're using a mouse, we want to make sure we only handle moving
            // if we're actually dragging the carousel item
            if (this.usingMouse && !this.mouseDown) {
                return;
            }

            // If we are under the drag threshold, prevent further dragging
            if (isUnderDragThreshold) {
                return;
            }

            // Only prevent dragging while we aren't already dragging
            if (!dragging) {
                // If we are scrolling past, prevent further dragging
                if (isScrollingPast) {
                    return;
                }

                // determine if the user is trying to scroll past the carousel
                if (Math.abs(deltaY) > Math.abs(deltaX)) {
                    // We know we're scrolling past now, so prevent
                    // further dragging
                    this.setState({ isScrollingPast: true });
                    return;
                }
            }

            // Set the carousel to "dragging" to ensure all dragging animation
            // happens until the user finishes
            this.setState({ dragging: true });

            // While dragging, prevent app from being scrollable
            if (document.ontouchstart === null || document.ontouchstart === undefined) {
                document.ontouchstart = preventDefault;
                document.ontouchmove = preventDefault;
            }

            var direction = deltaX < 0 ? DIRECTION_RIGHT : DIRECTION_LEFT;

            // Disallow dragging in a direction that you can't move to.
            if (this.canMove(direction)) {
                // Account for the threshold, or the content will jump to
                // cursor position'
                var newDeltaX = deltaX + (direction === DIRECTION_RIGHT ? 1 : -1) * dragThreshold;

                this.setState({
                    animate: true,
                    deltaX: newDeltaX
                });
            }
        }
    }, {
        key: 'onMouseDownHandler',
        value: function onMouseDownHandler(e) {
            this.mouseDown = true;
            this.onDownHandler(e);
        }
    }, {
        key: 'onMouseUpHandler',
        value: function onMouseUpHandler(e) {
            this.mouseDown = false;
            this.onUpHandler(e);
        }
    }, {
        key: 'onMouseMoveHandler',
        value: function onMouseMoveHandler(e) {
            this.usingMouse = true;
            this.onMoveHandler(e);
        }
    }, {
        key: 'onTouchMoveHandler',
        value: function onTouchMoveHandler(e) {
            this.usingMouse = false;
            this.onMoveHandler(e);
        }
    }, {
        key: 'onLeaveHandler',
        value: function onLeaveHandler() {
            this.mouseDown = false;

            if (this.state.dragging) {
                this.onUpHandler();
            }
        }
    }, {
        key: 'onPreviousHandler',
        value: function onPreviousHandler() {
            !this.state.dragging && this.move(DIRECTION_LEFT);
        }
    }, {
        key: 'onNextHandler',
        value: function onNextHandler() {
            !this.state.dragging && this.move(DIRECTION_RIGHT);
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props3 = this.props,
                animationDuration = _props3.animationDuration,
                className = _props3.className,
                previousIcon = _props3.previousIcon,
                nextIcon = _props3.nextIcon,
                iconSize = _props3.iconSize,
                buttonClass = _props3.buttonClass,
                showCaption = _props3.showCaption,
                showControls = _props3.showControls,
                showPips = _props3.showPips,
                getNextMessage = _props3.getNextMessage,
                getPipMessage = _props3.getPipMessage,
                getPreviousMessage = _props3.getPreviousMessage;
            var _state4 = this.state,
                animate = _state4.animate,
                currentIndex = _state4.currentIndex,
                deltaX = _state4.deltaX,
                dragging = _state4.dragging,
                prevIndex = _state4.prevIndex,
                nextIndex = _state4.nextIndex;
            var children = this.props.children;


            var classes = (0, _classnames2.default)('pw-carousel', className);

            if (!_react2.default.Children.count(children)) {
                return false;
            }

            // Ensure that deltaX must be greater than 0 in order for animations to
            // occur, otherwise you might get an undersirable animate-forward-
            // animate-back effect.
            var duration = dragging ? 0 : animationDuration;
            var innerStyle = (0, _static2.default)(deltaX && animate && animationDuration ? { transform: 'translate3d(' + deltaX + 'px, 0, 0)', transition: 'transform ' + duration.toString() + 's ease-in-out' } : { transform: 'translate3d(0, 0, 0)', transition: 'none' });
            var animatingProps = { isAnimating: animate, isDragging: dragging };

            var slideCount = _react2.default.Children.count(children);

            // Handle the case where there is only a single child correctly
            var currentChild = children[currentIndex] || children;
            currentChild = _react2.default.cloneElement(currentChild, (0, _extends3.default)({}, animatingProps, {
                active: true,
                key: getKey(currentIndex) }));

            // If we have only one child, prev and next can be null
            var prevChild = slideCount > 1 ? _react2.default.cloneElement(children[prevIndex], (0, _extends3.default)({}, animatingProps, {
                key: getKey(prevIndex) })) : null;

            // If we have two children, we need to have a dummy 'next' one,
            // so we'll clone the prev and give it a new key
            var nextChild = function () {
                if (slideCount > 2) {
                    return _react2.default.cloneElement(children[nextIndex], (0, _extends3.default)({}, animatingProps, {
                        key: getKey(nextIndex) }));
                } else if (slideCount > 1 && prevChild) {
                    return _react2.default.cloneElement(prevChild, (0, _extends3.default)({}, animatingProps, {
                        key: getKey(prevIndex + '-duplicate')
                    }));
                } else {
                    return null;
                }
            }();

            var childList = [prevChild, currentChild, nextChild];

            return _react2.default.createElement(
                'div',
                { className: classes },
                _react2.default.createElement(
                    'div',
                    (0, _extends3.default)({ className: 'pw-carousel__inner',
                        style: innerStyle,
                        onTransitionEnd: this.moveComplete
                    }, this.eventHandlers, {
                        ref: function ref(el) {
                            _this2._innerWrapper = el;
                        }
                    }),
                    childList.map(function (item) {
                        return item;
                    })
                ),
                showCaption && _react2.default.createElement(
                    'span',
                    { className: 'pw-carousel__caption' },
                    currentChild.props.caption
                ),
                (showControls || showPips) && _react2.default.createElement(
                    'div',
                    { className: 'pw-carousel__controls' },
                    showControls && _react2.default.createElement(_carouselButton2.default, {
                        className: 'pw-carousel__previous',
                        onClick: this.onPreviousHandler,
                        disabled: !this.canMove(DIRECTION_LEFT),
                        buttonClass: buttonClass,
                        icon: previousIcon,
                        iconSize: iconSize,
                        title: getPreviousMessage(prevIndex + 1, slideCount),
                        analyticsContent: _dataObjects.UI_NAME.previous
                    }),
                    (showControls || showPips) && _react2.default.createElement(
                        'div',
                        { className: 'pw-carousel__pips' },
                        _react2.default.Children.map(children, function (item, index) {
                            var isCurrentPip = index === currentIndex;
                            return _react2.default.createElement(
                                _carouselPip2.default,
                                {
                                    isCurrentPip: isCurrentPip,
                                    key: index
                                },
                                getPipMessage(isCurrentPip, index + 1)
                            );
                        })
                    ),
                    showControls && _react2.default.createElement(_carouselButton2.default, {
                        className: 'pw-carousel__next',
                        onClick: this.onNextHandler,
                        disabled: !this.canMove(DIRECTION_RIGHT),
                        buttonClass: buttonClass,
                        icon: nextIcon,
                        iconSize: iconSize,
                        title: getNextMessage(nextIndex + 1, slideCount),
                        analyticsContent: _dataObjects.UI_NAME.next
                    })
                )
            );
        }
    }]);
    return Carousel;
}(_react2.default.PureComponent);

var defaultGetNextMessage = function defaultGetNextMessage(nextIndex, total) {
    return 'Show slide ' + nextIndex + ' of ' + total;
};

var defaultGetPreviousMessage = function defaultGetPreviousMessage(previousIndex, total) {
    return 'Show slide ' + previousIndex + ' of ' + total;
};

var defaultGetPipMessage = function defaultGetPipMessage(isCurrentPip, slideIndex) {
    return isCurrentPip ? 'Current slide: ' + slideIndex : 'Slide ' + slideIndex;
};

Carousel.defaultProps = {
    allowLooping: false,
    animationDuration: 0.5,
    dragThreshold: 10,
    getNextMessage: defaultGetNextMessage,
    getPipMessage: defaultGetPipMessage,
    getPreviousMessage: defaultGetPreviousMessage,
    iconSize: 'small',
    moveThreshold: 50,
    nextIcon: 'caret-circle-right',
    previousIcon: 'caret-circle-left',
    showCaption: false,
    showControls: true,
    showPips: false,
    onSlideMove: function onSlideMove() {}
};

Carousel.propTypes = {
    /**
     * AllowLooping will cause the carousel to start at the beginning on the next move
     * when the end is reached.
     */
    allowLooping: _propTypes2.default.bool,

    /**
     * Duration will define the time the animation takes to complete.
     */
    animationDuration: _propTypes2.default.number,

    /**
     * Adds values to the `class` attribute for the Previous/Next buttons.
     */
    buttonClass: _propTypes2.default.string,

    /**
     * The CarouselItems to display.
     *
     * Because of the way this component handles animation,
     * only 3 will ever be rendered at a time.
     */
    children: _propTypes2.default.node,

    /**
     * Adds values to the `class` attribute of the root element.
     */
    className: _propTypes2.default.string,

    /**
     * The index of the current slide. This prop can be used to set the active slide to an index of your choice.
     */
    currentSlide: _propTypes2.default.number,

    /**
     * Number value in pixels representing the distance the user must drag their finger
     * over the carousel item before it starts dragging.
     */
    dragThreshold: _propTypeUtils.positiveNumber,

    /**
     * This function should return a string (or node) that describes the user's current location in the carousel.
     * It will be passed the next slide index and total number of slides.
     */
    getNextMessage: _propTypes2.default.func,

    /**
     * This function should return a string (or node) that describes the meaning of each individual "pip" of
     * the carousel. This function is run for each pip, and is passed whether the pip is the _current_ pip, and
     * the pip's slide index.
     */
    getPipMessage: _propTypes2.default.func,

    /**
     * This function should return a string (or node) that describes the user's current location in the carousel.
     * It will be passed the previous slide index and total number of slides.
     */
    getPreviousMessage: _propTypes2.default.func,

    /**
     * Icon size for the Previous/Next buttons.
     */
    iconSize: _propTypes2.default.string,

    /**
     * Number value in pixels representing the distance the carousel item must be dragged
     * before it qualifies as a valid move.
     */
    moveThreshold: _propTypeUtils.positiveNumber,

    /**
     * Icon name for the "Next Button".
     * For more information about available icons, see the [Icon component](#!/Icon).
     */
    nextIcon: _propTypes2.default.string,

    /**
     * Icon name for the "Previous Button".
     * For more information about available icons, see the [Icon component](#!/Icon).
     */
    previousIcon: _propTypes2.default.string,

    /**
     * Boolean value to show slide caption or not. The caption is read
     * from the props of the current CarouselItem.
     */
    showCaption: _propTypes2.default.bool,

    /**
     * Boolean value to show carousel controls and pips or not.
     */
    showControls: _propTypes2.default.bool,

    /**
     * Determines hidden controls and display pips.
     * Set this to `true` in combination with `showControls` set to false if
     * you want pips to remain visible while controls are hidden.
     */
    showPips: _propTypes2.default.bool,

    /**
     * Callback that triggers at the end of the `moveComplete` "event"
     */
    onSlideMove: _propTypes2.default.func
};

exports.default = Carousel;