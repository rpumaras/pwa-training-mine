'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _button = require('../button');

var _button2 = _interopRequireDefault(_button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The `LazyLoader` makes it possible to delay rendering of content until the
 * user has actually scrolled a certain distance through a page.
 *
 * A few common patterns for this component include:
 *
 * * Lazily fetch contents from a server when the user scrolls that content
 *   into view.
 * * Lazily render items, if rendering all of the items at once is a
 *   performance concern.
 *
 * The way this works is: when the `LazyLoader` scrolls into view, it triggers
 * a function callback to `fetchItems` (a Promise) to achieve the various lazy
 * loading effects. See example usages below.
 *
 * @example ./DESIGN.md
 */

/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

var LazyLoader = function (_React$Component) {
    (0, _inherits3.default)(LazyLoader, _React$Component);

    function LazyLoader(props) {
        (0, _classCallCheck3.default)(this, LazyLoader);

        var _this = (0, _possibleConstructorReturn3.default)(this, (LazyLoader.__proto__ || (0, _getPrototypeOf2.default)(LazyLoader)).call(this, props));

        _this.state = {
            shouldNotifyUser: false,
            loading: false,
            done: false
        };

        _this.handleScroll = _this.handleScroll.bind(_this);
        _this.loadNext = _this.loadNext.bind(_this);
        _this.reset = _this.reset.bind(_this);
        _this.checkIfDone = _this.checkIfDone.bind(_this);
        return _this;
    }

    (0, _createClass3.default)(LazyLoader, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            window.addEventListener('scroll', this.handleScroll);
            this.checkIfDone();
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            this.checkIfDone(nextProps);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            window.removeEventListener('scroll', this.handleScroll);
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.setState({
                loading: false,
                done: false
            });
        }
    }, {
        key: 'loadNext',
        value: function loadNext() {
            var _this2 = this;

            var _props = this.props,
                currentItemCount = _props.currentItemCount,
                itemsPerPage = _props.itemsPerPage,
                fetchItems = _props.fetchItems;


            this.setState({
                loading: true,
                shouldNotifyUser: false
            });

            fetchItems && fetchItems({
                startPosition: currentItemCount,
                lastPosition: currentItemCount + itemsPerPage
            }).then(function () {
                _this2.setState({
                    loading: false,
                    shouldNotifyUser: true
                });
            });
        }
    }, {
        key: 'handleScroll',
        value: function handleScroll() {
            var useLoadMoreButton = this.props.useLoadMoreButton;
            var _state = this.state,
                loading = _state.loading,
                done = _state.done;


            if (loading || done || useLoadMoreButton) {
                return;
            }

            var bottomPosition = this.el.getBoundingClientRect().bottom;

            if (bottomPosition <= window.innerHeight) {
                this.loadNext();
            }
        }
    }, {
        key: 'checkIfDone',
        value: function checkIfDone(props) {
            var _ref = props || this.props,
                currentItemCount = _ref.currentItemCount,
                itemTotal = _ref.itemTotal;

            var done = this.state.done;


            if (currentItemCount >= itemTotal && !done) {
                this.setState({
                    done: true,
                    loading: false
                });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var _props2 = this.props,
                allItemsLoadedMessage = _props2.allItemsLoadedMessage,
                notificationAddedMessage = _props2.notificationAddedMessage,
                children = _props2.children,
                className = _props2.className,
                loadMoreButtonClassName = _props2.loadMoreButtonClassName,
                loadMoreItemsMessage = _props2.loadMoreItemsMessage,
                loadingIndicator = _props2.loadingIndicator,
                relevantText = _props2.relevantText,
                useLoadMoreButton = _props2.useLoadMoreButton;
            var _state2 = this.state,
                done = _state2.done,
                loading = _state2.loading,
                shouldNotifyUser = _state2.shouldNotifyUser;


            var classes = (0, _classnames2.default)('pw-lazy-loader', className);
            var loadMoreButtonClasses = (0, _classnames2.default)('pw-lazy-loader__load-more', loadMoreButtonClassName);

            return _react2.default.createElement(
                'div',
                {
                    className: classes,
                    ref: function ref(el) {
                        _this3.el = el;
                    }
                },
                children,
                useLoadMoreButton && _react2.default.createElement(
                    _button2.default,
                    {
                        className: loadMoreButtonClasses,
                        onClick: this.loadNext,
                        disabled: loading || done
                    },
                    done ? allItemsLoadedMessage : loadMoreItemsMessage
                ),
                loading && _react2.default.createElement(
                    'div',
                    { className: 'pw-lazy-loader__indicator' },
                    loadingIndicator
                ),
                _react2.default.createElement(
                    'div',
                    {
                        className: 'u-visually-hidden',
                        'aria-live': 'polite',
                        'aria-relevant': relevantText,
                        tabIndex: '-1'
                    },
                    shouldNotifyUser && notificationAddedMessage
                )
            );
        }
    }]);
    return LazyLoader;
}(_react2.default.Component);

LazyLoader.defaultProps = {
    allItemsLoadedMessage: 'All items loaded',
    itemsPerPage: 20,
    itemTotal: Number.POSITIVE_INFINITY,
    loadMoreItemsMessage: 'Load more items',
    loadingIndicator: 'Loading...',
    notificationAddedMessage: 'More items loaded',
    relevantText: 'additions text'
};

LazyLoader.propTypes = {
    /**
     * The current number of items. We cannot determine this based on the number
     * of children in case the children are wrapped in another component, such
     * as a Grid component providing layout.
     */
    currentItemCount: _propTypes2.default.node.isRequired,

    /**
     * A user-defined function that is called when the bottom of the LazyLoader
     * component scrolls into view. This provides the user with a hook to
     * perform network requests to fetch and load more content. This function
     * must return a promise that resolves when any fetched content is loaded.
     */
    fetchItems: _propTypes2.default.func.isRequired,

    /**
     * A message used on the Load More Items button when all items have loaded.
     * Exposed to screen readers.
     */
    allItemsLoadedMessage: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.node]),

    /**
     * The children to be rendered.
     */
    children: _propTypes2.default.node,

    /**
     * Adds values to the `class` attribute of the root element.
     */
    className: _propTypes2.default.string,

    /**
     * A user-defined number that indicates the end state of the LazyLoader.
     * When the LazyLoader has loaded this many items, then it knows it can stop
     * attempting to load more items.
     */
    itemTotal: _propTypes2.default.number,

    /**
     * The number of items to load for each page.
     */
    itemsPerPage: _propTypes2.default.number,

    /**
     * Adds values to the `class` attribute of the load more button.
     */
    loadMoreButtonClassName: _propTypes2.default.string,

    /**
     * A message used on the Load More Items button. Exposed to screen readers.
     */
    loadMoreItemsMessage: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.node]),

    /**
     * An indicator that the next page of contents is loading.
     */
    loadingIndicator: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.node]),

    /**
     * A message exposed to screen readers when new contents have been loaded.
     */
    notificationAddedMessage: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.node]),

    /**
     * The `LazyLoader` component uses [ARIA Live Regions](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)
     * to report updates to users using assistive tools like screen readers.
     * The `relevantText` prop describes which types of changes are relevant to
     * the Live Region, which tells the assistive tool which changes to report
     * to the user. This text is fed into an `aria-relevant` prop, accepts a
     * space delimited list of one or more of the following values: `additions`,
     * `removals`, `text` or `all`. See [here](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-relevant_attribute)
     * for details.
     */
    relevantText: _propTypes2.default.string,

    /**
     * Indicates if the load more button should be used instead of scrolling.
     */
    useLoadMoreButton: _propTypes2.default.bool
};

exports.default = LazyLoader;