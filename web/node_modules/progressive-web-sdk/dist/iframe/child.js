'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Initialize the ChildFrame
 *
 * @param {object} [options={}] - options object for configuring the child frame
 *   @param {string} [origin=window.location.origin] - used to listen to messages only sent over the same domain
 *   @param {boolean} [debug=false] - whether to log messages to console and display the iframe contents
 *   @param {Promise} [readyCheck] - a Promise that resolves when the child frame content has loaded
 * @returns {this}
 */
var ChildFrame = function ChildFrame(options) {
    var _this = this;

    if (window.Progressive && window.Progressive.ChildFrame) {
        return window.Progressive.ChildFrame;
    } else {
        window.Progressive = window.Progressive || {};
        window.Progressive.ChildFrame = this;
    }

    // Call the Frame constructor and provide it the correct `this` context
    _common.Frame.call(this);
    this.options = (0, _extends3.default)({}, this.options, options);
    this.parentWindow = null;
    this.rpcMethods = {};

    // Method for telling if we should process the received message
    this._isSameOrigin = function (event) {
        return event.origin === _this.options.origin && event.source === _this.parentWindow;
    };

    // Bind handler methods to the new object
    this._navigateHandler = this._navigateHandler.bind(this);
    this._rpcHandler = this._rpcHandler.bind(this);

    // Add `[Child]` before every call to _log
    this._log = this._log.bind(this, '[Child]');

    return this._start();
};

// Inherit the prototype from our common Frame module
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

ChildFrame.prototype = new _common.Frame();

// Private method for initializing the child module
ChildFrame.prototype._start = function () {
    var _this2 = this;

    // Set up child message listener
    window.addEventListener('message', this._eventReceived.bind(this, this._isSameOrigin), false);

    // We need a reference to the parent window to pass messages properly
    this.parentWindow = window.top;
    this._sendMessage = this._sendMessage.bind(this, this.parentWindow);

    this.on(_common.DEFAULT_EVENTS.NAVIGATE, this._navigateHandler);
    this.on(_common.DEFAULT_EVENTS.RPC_CALL, this._rpcHandler);

    var ready = function ready() {
        _this2._log('ready');
        _this2.trigger(_common.DEFAULT_EVENTS.CHILD_READY);
    };

    // User-supplied Promise for determining that the child frame has finished
    // loading
    if (this.options.readyCheck) {
        this.options.readyCheck.then(ready);
    } else if (document.readyState === 'interactive') {
        // If the document is already in 'interactive' we've passed the
        // DOMContentLoaded event and just trigger `ready` manually.
        // HTML Spec: https://html.spec.whatwg.org/#the-end
        ready();
    } else {
        // Otherwise, just wait for a sane default, in this case, DOMContentLoaded
        document.addEventListener('DOMContentLoaded', ready, false);
    }

    return this;
};

// Navigate the iframe in response to a message.
ChildFrame.prototype._navigateHandler = function (_ref) {
    var url = _ref.url;

    if (url !== window.location.href) {
        this._log('child navigating to', url);
        this.trigger(_common.DEFAULT_EVENTS.CHILD_NAVIGATING);
        // If we use window.location.href = url here,
        // a new entry will be added to the iframe's history.
        // The child iframe and the top level frame share a history,
        // so when the user hits the back button,
        // the iframe will navigate instead of the top level page.
        // By using replace, we don't add a new item to the history,
        // and the back button works as expected.
        window.location.replace(url);
    }
};

// Listen for RPC calls from parent and send back a message after the method
// has run
ChildFrame.prototype._rpcHandler = function (_ref2) {
    var _this3 = this;

    var uid = _ref2.uid,
        fnName = _ref2.fnName,
        args = _ref2.args;

    var fcn = this.rpcMethods[fnName];

    if (typeof fcn === 'undefined') {
        return this.options.debug && console.warn('[Child] unregistered method called:', fnName);
    } else {
        return _promise2.default.resolve(fcn.apply(this, args)).then(function (res) {
            return _this3.trigger(_common.DEFAULT_EVENTS.RPC_CALL + ':' + uid, res);
        });
    }
};

/**
 * Register a method that can be invoked by the parent
 *
 * @param {string} fnName - the unique name of the method
 * @param {function} method - the function that should be invoked. Can return a Promise
 * @returns {this}
 */
ChildFrame.prototype.registerMethod = function (fnName, method) {
    this._log('registered method', fnName);
    this.rpcMethods[fnName] = method;

    return this;
};

exports.default = ChildFrame;