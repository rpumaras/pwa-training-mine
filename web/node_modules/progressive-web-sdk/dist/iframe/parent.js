'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _queueSrc = require('../../vendor/queue.src.js');

var _queueSrc2 = _interopRequireDefault(_queueSrc);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Initialize the FrameBridge
 *
 * @param {object} [options={}] - options object for configuring the bridge
 *   @param {string} [origin=window.location.origin] - used to listen to messages only sent over the same domain
 *   @param {boolean} [debug=false] - whether to log messages to console and display the iframe contents
 *   @param {string} [src=window.location.href] - the starting href of the child frame
 * @returns {this}
 */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

var FrameBridge = function FrameBridge(options) {
    var _this = this;

    // Since we could be running in completely separate modules (i.e. loader.js
    // as well as main.js) we need to attach ourselves to window object to
    // properly create an instance
    if (window.Progressive && window.Progressive.FrameBridge) {
        return window.Progressive.FrameBridge;
    } else {
        window.Progressive = window.Progressive || {};
        window.Progressive.FrameBridge = this;
    }

    // Call the Frame constructor and provide it the correct `this` context
    _common.Frame.call(this);
    // Populate our own properties
    this.options.src = window.location.href;
    this.options = (0, _extends3.default)({}, this.options, options);
    this.childFrame = null;
    this.eventQueue = new _queueSrc2.default();

    // Method for telling if we should process the received message
    this._isSameOrigin = function (event) {
        return event.origin === _this.options.origin && event.source === _this.childFrame.contentWindow;
    };

    // Add `[Parent]` before every call to _log
    this._log = this._log.bind(this, '[Parent]');

    // Unique ID to apply to RPC calls to child frame
    var callCount = 0;
    this.uid = function () {
        return callCount++;
    };

    return this._start();
};

// Inherit the prototype from our common Frame module
FrameBridge.prototype = new _common.Frame();

// Private method for initializing the parent module
FrameBridge.prototype._start = function () {
    // Set up parent message listener
    window.addEventListener('message', this._eventReceived.bind(this, this._isSameOrigin), false);

    // Listen for child frame loading complete
    this.on(_common.DEFAULT_EVENTS.CHILD_READY, this._childReadyHandler);

    // When the child frame navigates, we need to wait for it to be initialized
    // again after it's finished loading (i.e. `DEFAULT_EVENTS.CHILD_READY`)
    this.on(_common.DEFAULT_EVENTS.CHILD_NAVIGATING, this._navigateHandler);

    this._createChildFrame();

    this._bindChildFrameWindowToSendMessage();

    return this;
};

FrameBridge.prototype._bindChildFrameWindowToSendMessage = function () {
    // Bind `this` to the iframe bridge instance, and bind the first argument to the iframe window.
    this._sendMessage = this._sendMessage.bind(this, this.childFrame.contentWindow);
};

FrameBridge.prototype._childReadyHandler = function () {
    this.isReady = true;
    this._log('bridge ready');
    this._drainQueue();
};

FrameBridge.prototype._navigateHandler = function () {
    this._log('bridge waiting');
    this.isReady = false;
};

// Private method for creating the child iframe element
FrameBridge.prototype._createChildFrame = function () {
    this.childFrame = document.createElement('iframe');
    this.childFrame.setAttribute('id', 'progressive-frame-bridge');
    /**
     * Sandboxing the child frame lets us disable things like alerts and new windows
     * from being shown from within the child frame - but we need to:
     *
     * allow-scripts - scripts are still run in the child frame
     * allow-same-origin - without this, origin is set to null and causes a wide variety of broken behavior
     * allow-forms - allow forms to be submitted within the child frame
     *
     * @url: https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox
     */
    this.childFrame.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms');

    if (this.options.debug) {
        this.childFrame.style.height = '600px';
        this.childFrame.style.width = '100%';
    } else {
        this.childFrame.style.display = 'none';
    }

    document.body.appendChild(this.childFrame);
    this.childFrame.setAttribute('src', this.options.src);
};

// Private method for emptying the queue of events after child has signaled it's
// ready to receive them
FrameBridge.prototype._drainQueue = function () {
    while (!this.eventQueue.isEmpty()) {
        var _eventQueue$dequeue = this.eventQueue.dequeue(),
            eventName = _eventQueue$dequeue.eventName,
            data = _eventQueue$dequeue.data;

        this._sendMessage(eventName, data);

        // If a navigation event is in the queue, we want to wait until the page is ready
        // before we drain the queue, otherwise the queue events that are after the navigation
        // will be fired immediately when the page is not ready
        if (eventName === _common.DEFAULT_EVENTS.NAVIGATE) {
            break;
        }
    }
};

/**
 * Send an event to the child frame
 *
 * @param {string} eventName - the name of the event to trigger
 * @param {object} [data] - key/value pair containing information to send
 * @returns {this}
 */
FrameBridge.prototype.trigger = function (eventName, data) {
    if (this.isReady) {
        // If the bridge frame has loaded, send the event immediately
        _common.Frame.prototype.trigger.call(this, eventName, data);
    } else {
        // Otherwise, add it to a queue to be drained later
        this.eventQueue.enqueue({
            eventName: eventName,
            data: data
        });
    }

    return this;
};

/**
 * Tell the child frame to navigate to the given url
 *
 * @param {string} url - the url that should be set as `window.location.href` of the child frame
 * @returns {this}
 */
FrameBridge.prototype.navigate = function (url) {
    return this.trigger(_common.DEFAULT_EVENTS.NAVIGATE, { url: url });
};

/**
 * Invoke a method that was registered in the child frame
 *
 * @param {string} fnName - the name of the registered method to invoke
 * @params {...*} args - the arguments accepted by the registered method
 * @returns {Promise} - a thenable Promise that resolves after the child method returns or resolves
 */
FrameBridge.prototype.callMethod = function (fnName) {
    var _this2 = this;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
    }

    var uid = this.uid();
    return new _promise2.default(function (resolve) {
        _this2.trigger(_common.DEFAULT_EVENTS.RPC_CALL, {
            uid: uid,
            fnName: fnName,
            args: args
        });

        _this2.on(_common.DEFAULT_EVENTS.RPC_CALL + ':' + uid, function (data, eventName, eventData) {
            resolve({ data: data, eventName: eventName, eventData: eventData });
        });
    });
};

exports.default = FrameBridge;