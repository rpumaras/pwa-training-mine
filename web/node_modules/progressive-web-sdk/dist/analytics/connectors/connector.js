'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

var Connector = function () {
    (0, _createClass3.default)(Connector, null, [{
        key: 'loadScript',
        value: function loadScript(src, connector) {
            var boundOnload = connector.ready.bind(connector);

            var existingScript = document.querySelectorAll('script[src="' + src + '"]');
            if (existingScript.length > 0) {
                console.warn('You are attemping to load the same script more than once.');
                if (existingScript[0].ready) {
                    boundOnload();
                } else {
                    existingScript[0].loadQueue.push(boundOnload);
                }
                return;
            }

            var script = document.createElement('script');

            // Building the onload queue - this is to ensure that race condition doesn't happen
            // This is simpler than binding load event using addEventListener/addEvent(MS)
            script.ready = false;
            script.loadQueue = [];
            script.loadQueue.push(boundOnload);

            script.onload = function () {
                script.ready = true;
                var onloadCallback = void 0;
                while (onloadCallback = script.loadQueue.shift()) {
                    onloadCallback();
                }
            };
            script.async = 1;
            script.src = src;

            var firstScript = document.getElementsByTagName('script')[0];
            firstScript.parentNode.insertBefore(script, firstScript);
        }
    }, {
        key: 'debugHeading',
        value: function debugHeading(name, type) {
            return ['%c%s%c sends a %c%s%c event', 'color: #006EFF; font-size: 13px; line-height:30px;', name, 'color: inherit', 'color: #FF566A; font-size: 13px', type, 'color: inherit'];
        }
    }]);

    function Connector() {
        var displayName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.constructor.name;
        var options = arguments[1];
        (0, _classCallCheck3.default)(this, Connector);

        this.isReady = false;

        this.name = displayName.replace(/[\W\s]*/g, '');
        this.displayName = displayName;
        this.restrictedMethods = [];

        // Initialize queue
        this.q = [];

        this.options = (0, _extends3.default)({
            debug: false
        }, options);
    }

    (0, _createClass3.default)(Connector, [{
        key: 'ready',
        value: function ready() {
            this.isReady = true;
            this.receive();
        }
    }, {
        key: 'pageviewEvent',
        value: function pageviewEvent() {}

        /**
         * Performance Timings in order
         *
         * pageStart            When user navigates to this page (When the source document gets request to download)
         *                      No support for iOS Safari 10.3, Safari 10.1 - Safaris will have support at version 11
         * mobifyStart          Timing when tag initiates
         * firstPaint /         When first render is detected - Support Chrome 60+
         * firstContentfulPaint When first contentful render is detected - Support Chrome 60+
         * appStart             When loader.js initiates
         * templateWillMount    When view starts to render
         * templateDidMount     When view finishes render
         * templateAPIEnd       When view completes core data fetch
         * timeToInteractive    When there is no long task in execution
         *                      Support for PerformanceObserver Chrome 52.0+
         *
         * Resources:
         * PerformanceTiming    https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming/navigationStart
         * Paint Timing API     https://jmperezperez.com/paint-timing-api/
         * PerformanceObserver  https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver
         */

    }, {
        key: 'performanceEvent',
        value: function performanceEvent() {}
    }, {
        key: 'setCurrencyEvent',
        value: function setCurrencyEvent() {}
    }, {
        key: 'addToCartEvent',
        value: function addToCartEvent() {}
    }, {
        key: 'removeFromCartEvent',
        value: function removeFromCartEvent() {}
    }, {
        key: 'addToWishlistEvent',
        value: function addToWishlistEvent() {}
    }, {
        key: 'removeFromWishlistEvent',
        value: function removeFromWishlistEvent() {}
    }, {
        key: 'launchedFromHomeScreenEvent',
        value: function launchedFromHomeScreenEvent() {}
    }, {
        key: 'uiInteractionEvent',
        value: function uiInteractionEvent() {}
    }, {
        key: 'offlineModeUsedEvent',
        value: function offlineModeUsedEvent() {}
    }, {
        key: 'purchaseEvent',
        value: function purchaseEvent() {}
    }, {
        key: 'send',
        value: function send() {
            if (this.options.debug) {
                this.debug.apply(this, arguments);
            }
        }
    }, {
        key: 'debug',
        value: function debug(type) {
            var _console;

            (_console = console).log.apply(_console, (0, _toConsumableArray3.default)(Connector.debugHeading(this.displayName, type)));
        }
    }, {
        key: '_receive',
        value: function _receive(type, metaPayload, state) {
            var methodName = type + 'Event';
            if (this[methodName]) {
                var eventSent = this[methodName](metaPayload, state);
                if (eventSent) {
                    this.send(type, eventSent);
                }
            }
        }
    }, {
        key: 'receive',
        value: function receive() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            if (this.isReady) {
                // Drain queue
                if (this.q.length) {
                    var command = void 0;
                    while (command = this.q.shift()) {
                        this._receive.apply(this, (0, _toConsumableArray3.default)(command));
                    }
                }

                // Propagate event
                if (args.length) {
                    this._receive.apply(this, args);
                }
            } else {
                // Push to queue
                console.info(this.displayName + ' is not ready. Event \'' + args[0] + '\' is pushed to queue');
                this.q.push(args);
            }
        }
    }]);
    return Connector;
}();

exports.default = Connector;