'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setLocale = exports.notificationClick = exports.rehydrateVisitCountdowns = exports.rehydratePageCount = exports.incrementPageCount = exports.channelOfferShown = exports.subscribeOnClick = exports.subscribe = exports.decreaseVisitCountdowns = exports.startVisitCountdown = exports.setVisitCountdownsInStorage = exports.getVisitEndTimestamp = exports.setVisitEndTimestamp = exports.onLocaleSet = exports.onNotificationClick = exports.setVisitsToWaitIfDismissed = exports.messagingSystemAskShown = exports.onVisitCountdownStarted = exports.onPageCountIncrement = exports.onDecreaseVisitCountdowns = exports.stateUpdate = exports.onRehydratedVisitCountdowns = exports.onRehydratedPageCount = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _isReactRoute = require('../../routing/is-react-route');

var _isReactRoute2 = _interopRequireDefault(_isReactRoute);

var _routing = require('../../routing');

var _utils = require('../../utils/utils');

var _logger = require('../../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _actionCreation = require('../../utils/action-creation');

var _pushMessagingStore = require('./push-messaging-store');

var _pushMessagingStore2 = _interopRequireDefault(_pushMessagingStore);

var _selectors = require('./selectors');

var messagingSelectors = _interopRequireWildcard(_selectors);

var _constants = require('./constants');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

var logger = new _logger2.default('[Messaging UI]');

var onRehydratedPageCount = exports.onRehydratedPageCount = (0, _actionCreation.createAction)('[Push Messaging] Page Count Rehydrated');
var onRehydratedVisitCountdowns = exports.onRehydratedVisitCountdowns = (0, _actionCreation.createAction)('[Push Messaging] Visit Countdowns Rehydrated', [_constants.VISIT_COUNTDOWNS]);
var stateUpdate = exports.stateUpdate = (0, _actionCreation.createAction)('[Push Messaging] State Updated');
var onDecreaseVisitCountdowns = exports.onDecreaseVisitCountdowns = (0, _actionCreation.createAction)('[Push Messaging] Decrease Visit Countdowns');
var onPageCountIncrement = exports.onPageCountIncrement = (0, _actionCreation.createAction)('[Push Messaging] Increment Page Count');
var onVisitCountdownStarted = exports.onVisitCountdownStarted = (0, _actionCreation.createAction)('[Push Messaging] Visit Countdown Set', [_constants.VISITS_TO_WAIT, _constants.CHANNEL_NAME]);
var messagingSystemAskShown = exports.messagingSystemAskShown = (0, _actionCreation.createAction)('[Push Messaging] System Ask Shown/Not Shown', ['systemAskShown']);
var setVisitsToWaitIfDismissed = exports.setVisitsToWaitIfDismissed = (0, _actionCreation.createAction)('[Push Messaging] Set Visits to Wait when Dismissed', ['visitsToWaitIfDismissed']);
var onNotificationClick = exports.onNotificationClick = (0, _actionCreation.createAction)('[Push Messaging] Notification Clicked', ['url']);
var onLocaleSet = exports.onLocaleSet = (0, _actionCreation.createAction)('[Push Messaging] Locale Set', ['locale']);

var storage = new _pushMessagingStore2.default('pw');
var visitEndTimestamp = void 0;

/**
 * Sets a visit timestamp hours into the future. Each time the page count is
 * incremented, this value is checked against the current time (see `incrementPageCount`)
 *
 * @param {number} [durationOverride] - Used for testing
 */
var setVisitEndTimestamp = exports.setVisitEndTimestamp = function setVisitEndTimestamp(durationOverride) {
    return function () {
        var date = new Date();
        var duration = typeof durationOverride !== 'undefined' ? durationOverride : _constants.ACTIVE_VISIT_DURATION;

        visitEndTimestamp = date.getTime() + duration * 1000; // convert to milliseconds

        logger.log('Current time is ' + date.toTimeString() + '.', 'Setting new visit end timestamp for ' + new Date(visitEndTimestamp).toTimeString());
    };
};

/**
 * Exported for testing. Returns the value of the local variable `visitEndTimestamp`
 *
 * @returns {number} - Visit end timestamp value in milliseconds
 */
var getVisitEndTimestamp = exports.getVisitEndTimestamp = function getVisitEndTimestamp() {
    return visitEndTimestamp;
};

/**
 * loader.js sets up messaging by adding a promise on `window.Progressive` that
 * we can chain off - once the Messaging Client is loaded it resolves and we can
 * safely call methods on window.Progressive.MessagingClient
 *
 * @returns {boolean} - true if promise is present, false otherwise
 */
var wasMessagingInitialized = function wasMessagingInitialized() {
    if (typeof window.Progressive.MessagingClientInitPromise === 'undefined') {
        console.error('Push Messaging is not ready: the client library may have failed to load or the project is misconfigured.\n' + '- Is the Push Messaging feature enabled for your project?\n' + '- Did you add the PushMessagingController component to the App container?\n');
        return false;
    }

    return true;
};

/**
 * Helper method to log error messages to console when invalid string arg is provided
 *
 * @param {string} logName - Prepended to log message
 * @param {string} argument - The argument to check for string type and length
 * @returns {boolean} - true if invalid string argument, false otherwise
 */
var isInvalidString = function isInvalidString(logName, argument) {
    if (typeof argument !== 'string' || argument.length === 0) {
        logger.forceLog(logName + ' must be specified as a string.');
        return true;
    }

    return false;
};

/**
 * Retrieves the visit countdowns object from the Redux store, and adds it to
 * local storage.
 */
var setVisitCountdownsInStorage = exports.setVisitCountdownsInStorage = function setVisitCountdownsInStorage() {
    return function (_, getState) {
        var currentCountdowns = messagingSelectors.getVisitCountdowns(getState()).toJS();
        storage.set(_constants.VISIT_COUNTDOWNS, currentCountdowns, _constants.PERMA_DURATION);
    };
};

/**
 * Starts a visit countdown that can be used to help in determining eligibility
 * of a particular Push Messaging "ask" component
 *
 * Is persisted in local storage for 1 year
 *
 * @param {number} visitsToWait - how many visits to wait for
 * @param {string} [channelName] - optional name of channel
 */
var startVisitCountdown = exports.startVisitCountdown = function startVisitCountdown(visitsToWait, channelName) {
    return function (dispatch) {
        channelName = channelName || _constants.DEFAULT_CHANNEL;
        dispatch(onVisitCountdownStarted(visitsToWait, channelName));

        logger.log('started visit countdown of ' + visitsToWait + ' for channel ' + channelName);
        dispatch(setVisitEndTimestamp());
        dispatch(setVisitCountdownsInStorage());
    };
};

/**
 * Decreases the current visit countdown by 1, saving the new value in local storage
 */
var decreaseVisitCountdowns = exports.decreaseVisitCountdowns = function decreaseVisitCountdowns() {
    return function (dispatch) {
        // First, decrease the visit countdowns in Redux store
        dispatch(onDecreaseVisitCountdowns());

        logger.log('Decreased visit countdowns by 1');
        // Finally, update localStorage with the latest page count
        dispatch(setVisitCountdownsInStorage());
    };
};

/**
 * Triggers the system-ask dialog to ask user for permissions. If user has already
 * provided permission, subscribes or unsubscribes them to the provided channel(s).
 * Provide a key representing the channel name, and a truthy value to subscribe
 * or falsy value to unsubscribe. Providing zero arguments will cause the Messaging
 * Client to subscribe the user to a `broadcast` channel.
 *
 * e.g.
 * {
 *   newDeals: true,
 *   priceDrops: false
 * }
 *
 * @param {object} [channels] - list of channels to un/subscribe to
 * @returns {Promise} resolves to a Push Messaging State, or undefined in case of error
 */
var subscribe = exports.subscribe = function subscribe(channels) {
    return function (dispatch, getState) {
        if (!wasMessagingInitialized()) {
            return _promise2.default.resolve();
        }

        return window.Progressive.MessagingClientInitPromise.then(function () {
            var isSubscribed = messagingSelectors.isSubscribed(getState());
            // The system ask is only shown if the user has not already subscribed
            // to push notifications on the domain
            if (!isSubscribed) {
                dispatch(messagingSystemAskShown(true)); // Let app know system ask is in progress
            }

            var message = 'Attempting subscription';

            // We only log channel names in the case that they were supplied -
            // otherwise we're only subscribing to the `broadcast` channel
            if (channels) {
                var channelKeys = (0, _keys2.default)(channels);
                message += ' to channel(s): ' + channelKeys.join(', ');
            }

            logger.log(message);
        }).then(function () {
            return window.Progressive.MessagingClient.subscribe(channels);
        }).then(function (state) {
            logger.forceLog('Attempted subscription. Result:', state);
            // It's safe to always dispatch this action
            dispatch(messagingSystemAskShown(false)); // Let app know the system ask is now hidden
            return state;
        }).catch( /* istanbul ignore next */function (err) {
            return console.error(err);
        });
    };
};

/**
 * Abstracts the `subscribe` action above so that it can be directly bound as a
 * React component's `onClick` event handler
 *
 * Handlers for the `onClick` event receive a `SyntheticEvent`
 * (https://facebook.github.io/react/docs/events.html) object as an argument,
 * which the `subscribe` method above does not expect. Use `subscribeOnClick` as
 * the handler to ignore this argument
 *
 * @returns {Promise} resolves to a Push Messaging State, or undefined in case of error
 */
var subscribeOnClick = exports.subscribeOnClick = function subscribeOnClick() {
    return subscribe();
};

/**
 * Informs the Push Messaging service that the given channel name was offered to the user
 * (Dispatch this action when UI asking user to subscribe to a channel has been shown,
 * typically in the `componentDidMount` and `componentDidUpdate` lifecycle methods)
 *
 * @param {string} [channel] - the name of the channel that was shown to the user
 * @returns {Promise} resolves to a Push Messaging State, or undefined in case of error
 */
var channelOfferShown = exports.channelOfferShown = function channelOfferShown(channel) {
    return function (dispatch) {
        if (!wasMessagingInitialized()) {
            return _promise2.default.resolve();
        }

        return window.Progressive.MessagingClientInitPromise.then(function () {
            logger.log('Notifying Messaging Client that channel ' + (channel || _constants.DEFAULT_CHANNEL) + ' was displayed.');
            return window.Progressive.MessagingClient.channelOfferShown(channel);
        }).catch( /* istanbul ignore next */function (err) {
            return console.error(err);
        });
    };
};

/**
 * For internal use, this adds 1 to the existing page counter and is dispatched by `onRouteChanged`
 * Also persists the value in local storage (for 6 hours)
 *
 * Each time this is called, the current time is checked against the value of
 * `visitEndTimestamp` (which is set on app initialization). If the current time
 * is greater than the timestamp, we count that as a "visit" and decrease visit
 * counters.
 *
 * @param {number} [count] - the number to increment the page count by
 */
var incrementPageCount = exports.incrementPageCount = function incrementPageCount() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return function (dispatch, getState) {
        // First, increment the page count
        dispatch(onPageCountIncrement(count));

        // Now that we've updated the store, get the current page count
        var currCount = messagingSelectors.getPageCount(getState());

        // Finally, update localStorage with the latest page count
        storage.set(_constants.PAGE_COUNT, currCount, _constants.ACTIVE_VISIT_DURATION);

        // Compare current time to determine whether enough time has elapsed since
        // app start to constitute a "visit"
        if (Date.now() >= visitEndTimestamp) {
            logger.log('A visit has elapsed since application start.');
            dispatch(decreaseVisitCountdowns());
            dispatch(setVisitEndTimestamp());
        }
    };
};

/**
 * For internal use, rehydrates any set page counts from local storage, and
 * adds it to Redux state
 */
var rehydratePageCount = exports.rehydratePageCount = function rehydratePageCount() {
    return function (dispatch) {
        var fromStore = storage.get(_constants.PAGE_COUNT);

        if (fromStore !== null) {
            dispatch(onRehydratedPageCount(fromStore));
        } else {
            // Since page count wasn't in storage, it expired. Decrease visit countdowns
            dispatch(decreaseVisitCountdowns());
        }
    };
};

/**
 * For internal use, rehydrates any set visit countdowns from  local storage, and
 * adds it to Redux state
 */
var rehydrateVisitCountdowns = exports.rehydrateVisitCountdowns = function rehydrateVisitCountdowns() {
    return function (dispatch) {
        var fromStore = storage.get(_constants.VISIT_COUNTDOWNS);

        if (fromStore !== null) {
            dispatch(onRehydratedVisitCountdowns(fromStore));
        }
    };
};

/**
 * Fired when a user clicks on a web push notification, the provided URL string
 * is first verified as a valid route in the React app, and then parsed as a relative
 * pathname. (including query string and hash)
 * If the URL provided does not match a valid route, then `location.href` is set
 * directly. (i.e. new page load)
 *
 * @param {string} url - a valid URL - typically from a Messaging Client event
 */
var notificationClick = exports.notificationClick = function notificationClick(url) {
    return function (dispatch) {
        if ((0, _isReactRoute2.default)(url)) {
            var relativeUrl = (0, _utils.extractPathFromURL)(url, true, true);
            _routing.browserHistory.push(relativeUrl);
        } else {
            window.location.href = url;
        }

        dispatch(onNotificationClick(url));
    };
};

/**
 * Sets the given locale as an attribute on the Messaging subscription - this is
 * useful for sending translated push notifications to subscribers.
 *
 * @param {string} locale - The locale of the visitor
 * @returns {Promise} resolves to a Push Messaging State, or undefined in case of error
 */
var setLocale = exports.setLocale = function setLocale(locale) {
    return function (dispatch) {
        if (!wasMessagingInitialized() || isInvalidString('Locale', locale)) {
            return _promise2.default.resolve();
        }

        return window.Progressive.MessagingClientInitPromise.then(function () {
            logger.log('Updating Messaging Client with locale: ' + locale + '.');
            dispatch(onLocaleSet(locale));
            return window.Progressive.MessagingClient.setLocale(locale);
        }).catch( /* istanbul ignore next */function (err) {
            return console.error(err);
        });
    };
};