'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _labSrc = require('../vendor/lab.src.js');

var _labSrc2 = _interopRequireDefault(_labSrc);

var _lodash = require('lodash.intersection');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

// LabJS is bound to window object - and does not export
var $ = void 0; // eslint-disable-line no-unused-vars

var IS_DEBUG = false;
var CACHED_URLS = {};
var INLINE_SCRIPTS = [];

var SRC_PROP = 'x-src';
var SELECTOR = 'script[' + SRC_PROP + '], script[type="text/mobify-script"]';
var SEARCHERS = {
    src: function src($script, query) {
        var src = $script.attr(SRC_PROP);

        return src && ($.type(query) === 'regexp' ? query.test(src) : $script.is('[' + SRC_PROP + '*="' + query + '"]'));
    },
    contains: function contains($script, query) {
        var src = $script.attr(SRC_PROP);
        var scriptContents = $script.text();

        return !src && ($.type(query) === 'regexp' ? query.test(scriptContents) : scriptContents.indexOf(query) >= 0);
    }
};

var LoadScripts = function LoadScripts(selectorLibrary) {
    if (LoadScripts.prototype._instance) {
        return LoadScripts.prototype._instance;
    }

    LoadScripts.prototype._instance = this;
    $ = selectorLibrary;

    return this;
};

// init only needs to be called once during run-time
LoadScripts.init = function (selectorLibrary) {
    var isDebug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    IS_DEBUG = isDebug;

    global.$LAB.setGlobalDefaults({
        // Preserve order of scripts passed to LabJS to ensure script execution order
        AlwaysPreserveOrder: true,
        // Don't re-inject scripts that were previously injected
        AllowDuplicates: false,
        Debug: IS_DEBUG
    });

    return LoadScripts.prototype._instance || new LoadScripts(selectorLibrary);
};

LoadScripts.prototype.inject = function (url, $response, searchTypes) {
    // Only process scripts for pages that haven't been scraped
    if (this._isDuplicateSearch(url, searchTypes)) {
        return;
    }

    var scripts = this._extract(url, $response, searchTypes);
    var scriptKeys = (0, _keys2.default)(scripts);

    for (var i = 0; i < scriptKeys.length; i++) {
        var script = scripts[scriptKeys[i]];
        var scriptSrc = script.getAttribute(SRC_PROP);

        if (scriptSrc) {
            global.$LAB.queueScript(scriptSrc);
        } else {
            (function () {
                var html = script.innerHTML;
                // LabJS "AllowDuplicates" option doesn't really handle inline
                // scripts - so we need to de-dupe ourselves
                if (INLINE_SCRIPTS.indexOf(html) < 0) {
                    // queueWait takes a callback that allows us to run any found
                    // inline scripts

                    /* eslint-disable no-loop-func */
                    global.$LAB.queueWait(function () {
                        INLINE_SCRIPTS.push(html);
                        eval(html); // eslint-disable-line no-eval

                        if (IS_DEBUG) {
                            console.log('inline script execution finished:\n', html);
                        }
                    });
                    /* eslint-enable no-loop-func */
                }
            })();
        }
    }

    // Finally, flush the queue and begin injecting scripts in order
    global.$LAB.runQueue();
};

LoadScripts.prototype._extract = function (url, $response, searchTypes) {
    var _this = this;

    var scripts = $response.find(SELECTOR).toArray();

    // Maintain script order from parsed document by inserting found scripts into
    // container object based on their array index. We'll inject each script into
    // the new document by iterating over the keys of the container
    var container = {};
    for (var searchType in searchTypes) {
        if (searchTypes.hasOwnProperty(searchType)) {
            (function () {
                var searchPatterns = _this._getSearchPatterns(searchTypes[searchType]);
                var searcher = SEARCHERS[searchType];
                var patternIndex = searchPatterns.length;

                // Update our cache of searched-for script patterns, by URL
                CACHED_URLS[url] = CACHED_URLS[url] || {};
                var cachedSearches = CACHED_URLS[url][searchType] || [];
                // Merge and de-dupe
                CACHED_URLS[url][searchType] = cachedSearches.concat(searchTypes[searchType].filter(function (item) {
                    return cachedSearches.indexOf(item) < 0;
                }).map(function (item) {
                    return item.toString();
                }));

                while (patternIndex--) {
                    var scriptIndex = scripts.length;

                    while (scriptIndex--) {
                        var script = scripts[scriptIndex];

                        if (searcher($(script), searchPatterns[patternIndex])) {
                            container[scriptIndex] = script;
                        }
                    }
                }
            })();
        }
    }

    return container;
};

LoadScripts.prototype._getSearchPatterns = function (searchType) {
    if ($.type(searchType) === 'regexp') {
        return [searchType];
    }

    if ($.type(searchType) === 'string') {
        if (searchType.indexOf(',') >= 0) {
            return searchType.replace(/\s/, '').split(',');
        }

        return [searchType];
    }

    return searchType;
};

// Check if the search pattern array is a subset of the cached array as a means
// of determining uniqueness
// http://stackoverflow.com/a/14130166
var isSubSet = function isSubSet(arr1, arr2) {
    return arr2.length === (0, _lodash2.default)(arr2, arr1).length;
};

// Iterate over the provided searchTypes object (which contains arrays keyed by
// search type (i.e. src, contains)), comparing them to our cached dictionary of
// previous searches. If we find any unique entry, return false. Otherwise, true.
LoadScripts.prototype._isDuplicateSearch = function (url, searchTypes) {
    if (typeof CACHED_URLS[url] === 'undefined') {
        return false;
    }

    var isDuplicate = false;
    for (var searchType in searchTypes) {
        if (searchTypes.hasOwnProperty(searchType)) {
            var searchPatterns = this._getSearchPatterns(searchTypes[searchType]).map(function (item) {
                return item.toString();
            });
            // If the new search array is a subset of our cached array, it means
            // we've already carried out those searches/extractions
            isDuplicate = isSubSet(CACHED_URLS[url][searchType], searchPatterns);
        }
    }

    return isDuplicate;
};

exports.default = LoadScripts;