'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recordRoutes = exports.extractRouteRegexes = exports.patternToRegex = exports.findRegexpMatches = exports.extractRoute = exports.doOneOrMany = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _lodash = require('lodash.escaperegexp');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var doOneOrMany = exports.doOneOrMany = function doOneOrMany(item, fn) {
    if (Array.isArray(item)) {
        var _ref;

        return (_ref = []).concat.apply(_ref, (0, _toConsumableArray3.default)(item.map(fn)));
    }
    return fn(item);
}; /* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

var extractRoute = exports.extractRoute = function extractRoute(route) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    var path = route.props.path;

    // This route has no path list relevance (e.g. it's an IndexRoute)
    // or it's a catch-all route
    if (!path) {
        return [];
    }

    // Remove the leading / from the path
    // The root route provides / as a prefix
    // so if we don't strip that out, we can end up with routes like
    // '//potions.html' which will not work correctly
    if (/\/$/.test(prefix)) {
        path = path.replace(/^\//, '');
    }
    var currentPath = '' + prefix + path.replace(/\/$/, '');

    var paths = [currentPath || '/'];

    if (route.props.children) {
        return paths.concat(doOneOrMany(route.props.children, function (child) {
            return extractRoute(child, currentPath + '/');
        }));
    }
    return paths;
};

var findRegexpMatches = exports.findRegexpMatches = function findRegexpMatches(regexp, text) {
    var lastIndex = 0;
    var matches = [];
    var match = void 0;

    while (match = regexp.exec(text)) {
        if (match.index !== lastIndex) {
            matches.push(text.slice(lastIndex, match.index));
        }

        matches.push(match);
        lastIndex = regexp.lastIndex;
    }

    if (lastIndex !== text.length) {
        matches.push(text.slice(lastIndex));
    }

    return matches;
};

var convertPatternPiece = function convertPatternPiece(match) {
    if (!Array.isArray(match)) {
        return (0, _lodash2.default)(match);
    }

    if (match[1]) {
        return '[^/]+';
    }
    if (match[0] === '(') {
        return '(?:';
    }
    if (match[0] === ')') {
        return ')?';
    }
    if (match[0] === '**') {
        return '.*';
    }
    // The regex below guarantees that this will always be true
    /* istanbul ignore else */
    if (match[0] === '*') {
        return '.*?';
    }
    /* istanbul ignore next */
    return '';
};

var patternToRegex = exports.patternToRegex = function patternToRegex(pattern) {
    var innerRegex = findRegexpMatches(/:([a-zA-Z_$][a-zA-Z0-9_$]*)|\(|\)|\*\*|\*/g, pattern).map(convertPatternPiece).join('');

    return '^' + innerRegex + '/?$';
};

var extractRouteRegexes = exports.extractRouteRegexes = function extractRouteRegexes(routes) {
    return doOneOrMany(routes, extractRoute).map(patternToRegex).map(function (text) {
        return RegExp(text);
    });
};

var recordRoutes = exports.recordRoutes = function recordRoutes(destinationFn, routes) {
    destinationFn(extractRouteRegexes(routes));
    return routes;
};

exports.default = recordRoutes;