'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isStandalone = exports.browserSupportsMessaging = exports.isSessionStorageAvailable = exports.isLocalStorageAvailable = exports.validatePageNumber = exports.documentWriteSupported = exports.loadScriptAsPromise = exports.loadScript = exports.preventDesktopSiteFromRendering = exports.getFirefoxVersion = exports.isFirefoxBrowser = exports.iOSBrowser = exports.isSamsungBrowser = exports.getChromeVersion = exports.urlToBasicPathKey = exports.urlToPathKey = exports.extractPathFromURL = exports.noop = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends4 = require('babel-runtime/helpers/extends');

var _extends5 = _interopRequireDefault(_extends4);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Copyright (c) 2018 Mobify Research & Development Inc. All rights reserved. */
/* * *  *  * *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

// This file contains functions used by the app 'loader.js'. It should be kept
// as small as possible to reduce the size of the loader.

/* istanbul ignore next */
var noop = exports.noop = function noop() {};

/**
* Converts a URL to the relative URL
* @param {string} url - the url to be converted (if it's already relative it will be returned as is)
* @param {bool} includeHash - indicates if the URL hash should be included in the relative URL returns
* @param {bool} includeQuery - indicates if the URL query should be included in the relative URL returns
*/
var extractPathFromURL = exports.extractPathFromURL = function extractPathFromURL(url) {
    var includeHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var includeQuery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var workingUrl = url;

    if (/^\//.test(workingUrl)) {
        // URL is relative, make it a full URL so we can use the same
        // logic below to rebuild the path.
        workingUrl = 'http://www.example.com' + workingUrl;
    }

    var urlObject = new URL(workingUrl);

    return '' + urlObject.pathname + (includeQuery ? urlObject.search : '') + (includeHash ? urlObject.hash : '');
};

/**
 * Converts a full URL to the preferred format for keying the redux store,
 * i.e. the path and query string
 */
var urlToPathKey = exports.urlToPathKey = function urlToPathKey(url) {
    return extractPathFromURL(url, false);
};

/**
 * Converts a full URL to the preferred format for keying the redux store,
 * i.e. only the path (without query string)
 */
var urlToBasicPathKey = exports.urlToBasicPathKey = function urlToBasicPathKey(url) {
    return extractPathFromURL(url, false, false);
};

/**
 * Get the major version of Chrome and return it as an integer.
 * If the browser isn't Chrome, return zero.
 * @param userAgent - the userAgent to test
 * @returns {Number}
 */
var getChromeVersion = exports.getChromeVersion = function getChromeVersion(userAgent) {
    var versionMatch = userAgent.match(/(Chrome|CriOS)\/(\d+)/i);
    var version = versionMatch && parseInt(versionMatch[2]);
    return version || 0;
};

var isSamsungBrowser = exports.isSamsungBrowser = function isSamsungBrowser(userAgent) {
    var samsungRegex = /SamsungBrowser/i;

    var chromeVersion = getChromeVersion(userAgent);

    // Some older Samsung devices have a default browser that's stuck on an old version of Chrome
    // We want to default to the responsive site for these devices
    // We know for sure that Chrome 28 doesn't work so we're using that as the cutoff for now
    var unsupportedChrome = chromeVersion && chromeVersion <= 28;

    // Page speed insights uses a chrome 27 user agent, so we need to explicitly support it
    var isPageSpeed = /Google Page Speed Insights/i.test(userAgent);

    return !isPageSpeed && (samsungRegex.test(userAgent) || unsupportedChrome);
};

/**
 * Return true if the given useragent is of a browser running on iOS.
 * We do this to allow detection of all iOS/webkit browsers in one test.
 * @param userAgent - the userAgent to test
 * @returns {Boolean}
 */
var iOSBrowser = exports.iOSBrowser = function iOSBrowser(userAgent) {
    return (/(iPad|iPhone|iPod)/g.test(userAgent)
    );
};

var isFirefoxBrowser = exports.isFirefoxBrowser = function isFirefoxBrowser(userAgent) {
    var firefoxRegex = /Firefox/i;
    var iOSFirefoxRegex = /FxiOS/i;

    return firefoxRegex.test(userAgent) || iOSFirefoxRegex.test(userAgent);
};

/**
 * Get the major version of Firefox. If the browser isn't Firefox, then
 * return zero
 * @param userAgent - the userAgent to test
 * @returns {Number}
 */
var getFirefoxVersion = exports.getFirefoxVersion = function getFirefoxVersion(userAgent) {
    var versionMatch = userAgent.match(/(Firefox|FxiOS)\/(\d+)/i);
    var version = versionMatch && parseInt(versionMatch[2]);
    return version || 0;
};

var preventDesktopSiteFromRendering = exports.preventDesktopSiteFromRendering = function preventDesktopSiteFromRendering() {
    if (document.querySelectorAll('plaintext').length > 0) {
        // If the plaintext tag is already present in the page, this means that
        // the desktop site has already been prevented from rendering. This
        // is due to the use of an older Mobify tag (pre V8), which inserts
        // the plaintext tag inline.
        return;
    }
    document.write('<plaintext style="display: none;">');
};

var hasTriedLoadScript = function hasTriedLoadScript(_ref) {
    var id = _ref.id,
        src = _ref.src,
        method = _ref.method;

    var idQuery = id ? '[id="' + id + '"]' : '';
    return document.querySelectorAll('script' + idQuery + ('[src="' + src + '"]') + ('[data-load-method="' + method + '"]')).length > 0;
};

var loadScriptCounter = 0;
var loadScript = exports.loadScript = function loadScript(_ref2) {
    var id = _ref2.id,
        src = _ref2.src,
        _ref2$isAsync = _ref2.isAsync,
        isAsync = _ref2$isAsync === undefined ? true : _ref2$isAsync,
        _ref2$docwrite = _ref2.docwrite,
        docwrite = _ref2$docwrite === undefined ? false : _ref2$docwrite,
        onload = _ref2.onload,
        onerror = _ref2.onerror;

    var loadMethod = docwrite ? 'document.write()' : 'DOM';
    if (hasTriedLoadScript({ id: id, src: src, method: loadMethod })) {
        console.warn('[mobify.progressive] loadScript() already called for this script. Ignoring call. (method=\'' + loadMethod + '\' id=\'' + id + '\' src=\'' + src + '\')');
        return;
    }

    if (onload && typeof onload !== 'function') {
        throw new Error('loadScript()\'s \'onload\' parameter must be a function but was passed a ' + (typeof onload === 'undefined' ? 'undefined' : (0, _typeof3.default)(onload)) + '!');
    }

    if (onerror && typeof onerror !== 'function') {
        throw new Error('loadScript()\'s \'onerror\' parameter must be a function but was passed a ' + (typeof onerror === 'undefined' ? 'undefined' : (0, _typeof3.default)(onerror)) + '!');
    }

    // TODO: Check for navigator.connection. Need Android for this.
    /* istanbul ignore next */
    if (docwrite && document.readyState === 'loading') {
        window.Mobify = window.Mobify || {};

        var onLoadString = '';
        var onErrorString = '';

        if (typeof onload === 'function') {
            window.Mobify.scriptOnLoads = (0, _extends5.default)({}, window.Mobify.scriptOnLoads, (0, _defineProperty3.default)({}, loadScriptCounter, onload));
            // Space prefix is important for valid rendered HTML
            onLoadString = ' onload="window.Mobify.scriptOnLoads[\'' + loadScriptCounter + '\'] && window.Mobify.scriptOnLoads[\'' + loadScriptCounter + '\']()"';
        }

        if (typeof onerror === 'function') {
            window.Mobify.scriptOnErrors = (0, _extends5.default)({}, window.Mobify.scriptOnErrors, (0, _defineProperty3.default)({}, loadScriptCounter, onerror));
            // Space prefix is important for valid rendered HTML
            onErrorString = ' onerror="window.Mobify.scriptOnErrors[\'' + loadScriptCounter + '\'] && window.Mobify.scriptOnErrors[\'' + loadScriptCounter + '\']()"';
        }

        document.write('<script id=\'' + id + '\' src=\'' + src + '\' data-load-method=\'' + loadMethod + '\' charset=\'utf-8\'' + onLoadString + onErrorString + '></script>');
        loadScriptCounter++;
    } else {
        var script = document.createElement('script');

        // Setting UTF-8 as our encoding ensures that certain strings (i.e.
        // Japanese text) are not improperly converted to something else. We
        // do this on the vendor scripts also just in case any libs we
        // import have localized strings in them.
        script.charset = 'utf-8';
        script.async = isAsync;
        if (id) {
            script.id = id;
        }
        script.src = src;
        script.dataset.loadMethod = loadMethod;

        /* istanbul ignore next */
        if (typeof onload === 'function') {
            script.onload = onload;
        }
        /* istanbul ignore next */
        if (typeof onerror === 'function') {
            script.onerror = onerror;
        }

        document.getElementsByTagName('head')[0].appendChild(script);
    }
};

var loadScriptAsPromise = exports.loadScriptAsPromise = function loadScriptAsPromise(_ref3) {
    var id = _ref3.id,
        src = _ref3.src,
        onload = _ref3.onload,
        _ref3$isAsync = _ref3.isAsync,
        isAsync = _ref3$isAsync === undefined ? true : _ref3$isAsync,
        _ref3$rejectOnError = _ref3.rejectOnError,
        rejectOnError = _ref3$rejectOnError === undefined ? true : _ref3$rejectOnError;
    return new _promise2.default(function (resolve, reject) {
        var resolver = function resolver() {
            /* istanbul ignore else */
            if (typeof onload === 'function') {
                onload();
            }
            resolve();
        };

        loadScript({
            id: id,
            src: src,
            onload: resolver,
            isAsync: isAsync,
            onerror: rejectOnError ? reject : /* istanbul ignore next */resolve
        });
    });
};

var documentWriteSupported = exports.documentWriteSupported = function documentWriteSupported() {
    // In Chrome, "Good 2G" has a download max of 0.439453125, thus we have
    // chosen our benchmark of 0.44 to determine if the connection is
    // poor. We have not specifically checked the connection type (ie cellular)
    // because in the future according to
    // https://developers.google.com/web/updates/2016/08/removing-document-write
    // the plan is to also have people on slow WiFi connections unable to
    // load the page via document.write.
    if (navigator.connection && navigator.connection.downlinkMax <= 0.44) {
        return false;
    }
    return true;
};

/**
 * Verify if page number is valid
 * If valid, return page number
 * If not valid, return first or last page number
 * @param {number} page - input page parameter to be verified
 * @param {number} count - optional parameter indicate total page count
 */
var validatePageNumber = exports.validatePageNumber = function validatePageNumber(page) {
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    page = parseInt(page);
    if (isNaN(page) || page < 1) {
        return 1;
    }
    if (count && page > count) {
        return count;
    }
    return page;
};

/*
 * Checks if the given storage type is available.
 * @param {Storage} storage
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Storage
 */
var isStorageAvailable = function isStorageAvailable(storage) {
    var x = '__test_key__';
    try {
        storage.setItem(x, x);

        // Test retrieving the set item
        if (x !== storage.getItem(x)) {
            throw new Error((typeof storage === 'undefined' ? 'undefined' : (0, _typeof3.default)(storage)) + ' is not supported in this environment!');
        }

        return true;
    } catch (e) {
        return false;
    } finally {
        try {
            storage.removeItem(x);
        } catch (e) {/* Swallow errors here */}
    }
};

/**
 * Checks if local storage is available in the current environment.
 */
var isLocalStorageAvailable = exports.isLocalStorageAvailable = function isLocalStorageAvailable() {
    return isStorageAvailable(localStorage);
};

/**
 * Checks if session storage is available in the current environment.
 */
var isSessionStorageAvailable = exports.isSessionStorageAvailable = function isSessionStorageAvailable() {
    return isStorageAvailable(sessionStorage);
};

/**
 * Checks if the browser supports Messaging - specifically, whether it supports
 * Mobify messaging, rather than W3C push notifications in general. Not all
 * browsers that support push are supported by Mobify, since the support for
 * the standards has evolved over time, and some older browsers have quirks
 * that mean we consider them unsupported.
 *
 * This function is Messaging-specific, but it's provided here in this SDK
 * file so that it's usable by the loader, without requiring the loader to
 * import yet another SDK module.
 *
 * This function will work for a PWA and also in non-PWA (standalone) mode,
 * so it will report true for browsers other than Chrome.
 *
 * The checks here are a combination of browser capability checks and version
 * checks for specific browsers. The minimum versions of browsers should align
 * with the supported browser version in the Messaging server file
 * https://github.com/mobify/pusheen/blob/master/backend/config.py
 *
 * This function does not check for Safari APNS push messaging support.
 *
 * @param userAgent - the userAgent to test - used for testing
 * @returns {Boolean}
 **/
var browserSupportsMessaging = exports.browserSupportsMessaging = function browserSupportsMessaging(userAgent) {
    // Browser capability checks
    if (!(
    // W3C Push Messaging (https://www.w3.org/TR/push-api/)
    // requires that the browser support service workers. Much
    // of the Push API is only available to service workers, and
    // this function is intended to work client-side, so we can't
    // check for full availability. However, if there's no
    // service worker support, there can be no Push API.
    navigator.serviceWorker &&
    // If Notification isn't present, we can't
    // check for or request permission to show notifications.
    window.Notification)) {
        return false;
    }

    // The browser supports service workers and the Notification
    // interface. However, the API has evolved over time, and support
    // is not always consistent across browsers, so we need to check
    // the browser name and minimum version. The minimum version numbers
    // here must match values in the Messaging backend (backend/config.js)
    var ua = userAgent || navigator.userAgent;

    // Exclude all iOS webkit browsers. As of iOS 10, they will also fail
    // the service-worker/Notification test above, but here we're guarding
    // against those features appearing in iOS before we have time to test
    // Messaging support.
    if (iOSBrowser(ua)) {
        return false;
    }

    // Check for Chrome
    var version = getChromeVersion(ua);
    if (version && version >= 46) {
        return true;
    }

    // Check for Firefox
    version = getFirefoxVersion(ua);
    if (version && version >= 46) {
        return true;
    }

    // This is not a browser that we explicitly support, so
    // the safest return is false.
    return false;
};

/**
 * This util is designed for use only when the app first launches in standalone mode.
 * The window.matchMedia check may fail on some versions of chrome even
 * if the app is in standalone mode and after the app launches and the user has
 * navigated elsewhere the URL may not contain ?homescreen=1 anymore.
 *
 * Using this util outside of when the app launches may produce false negatives
 *
 * If you need to check if the app is in standalone mode use the key stored
 * in the app branch of the redux store instead of this util.
 */
var isStandalone = exports.isStandalone = function isStandalone() {
    return (/homescreen=1/.test(window.location.href) || window.matchMedia('(display-mode: standalone)').matches
    );
};